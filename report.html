<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Copy Detection Report</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-uWxY/CJNBR+1zjPWmfnSnVxwRheevXITnMqoEIeG1LJrdI0GlVs/9cVSyPYXdcSF" crossorigin="anonymous">

  <style>
    h1 {
      text-align: center;
    }
    .highlight-green {
      background-color: #b6f2b6;
    }
    .highlight-red {
      background-color: #f2b6b6;
    }
    pre {
      text-align: left;
    }
    .col3 {
      float: left;
      width: 33%;
    }
    .file-info-list {
      max-height: 900px;
      overflow-y: scroll;
    }
    .main-report-div {
      margin-top: 3em;
      max-width: 1400px;
    }
    .code-display {
      max-width: 600px
    }
  </style></head>
<body>
<div class="container main-report-div">
  <h1 style="margin-bottom: 1em;">Copy Detection Report</h1>
  <h2>Overview</h2>
    <div class="container d-flex justify-content-center">
      <div class="col">
        <h4 style="text-align: center;">Similarity Matrix</h4>
        <img src="data:image/png;base64, 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" alt="Code similarity matrix">
      </div>
      <div class="col">
        <h4 style="text-align: center;">Similarity Score Distribution</h4>
        <img src="data:image/png;base64, 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uqUFCxbUruvZs2ed2b/Zs2enSZMmpaFDh+br7rrrrtSpU6e0dOnSdN555xVjNwEAQijKDOADDzyQ+vbtm773ve+ljh07pq9//evptttuq3197dq1acOGDflh3xpt27ZN/fr1SytXrizGLgIAhFGUAHznnXfSvHnz0uGHH54eeeSR9OMf/zj95Cc/SXfeeWf+ehZ/mWzGb3fZ85rX9rRt27ZUXV1dZwEAoEQOAe/atSufAbzhhhvy59kM4CuvvJKf7zdixIgv9DmnTZuWrrnmmn28pwAAjV9RZgCzK3uPPPLIOut69+6d1q1bl/+5c+fO+WNVVVWdbbLnNa/taeLEiWnTpk21y/r16+tt/wEAGpOiBGB2BfCaNWvqrHvzzTfToYceWntBSBZ6K1asqH09O6SbXQ3cv3//vX7Oli1bpoqKijoLAAAlcgh47NixacCAAfkh4HPOOSetWrUq3XrrrfmSKSsrS2PGjElTp07NzxPMgnDy5Mmpa9euadiwYcXYRQCAMIoSgCeccEJasmRJftj22muvzQMvu+3L8OHDa7cZP3582rJlSxo1alTauHFjGjRoUFq+fHkqLy8vxi4CAIRRVshuwtcIZIeMs1vHZOcD1vfh4B4TlqVieHf6kKJ8HQAgVvd4L2AAgGAEIABAMAIQACAYAQgAEIwABAAIRgACAAQjAAEAghGAAADBCEAAgGAEIABAMAIQACAYAQgAEIwABAAIRgACAAQjAAEAghGAAADBCEAAgGAEIABAMAIQACAYAQgAEIwABAAIRgACAAQjAAEAghGAAADBCEAAgGAEIABAMAIQACAYAQgAEIwABAAIRgACAAQjAAEAghGAAADBCEAAgGAEIABAMAIQACAYAQgAEIwABAAIRgACAAQjAAEAghGAAADBCEAAgGAEIABAMAIQACAYAQgAEIwABAAIRgACAAQjAAEAghGAAADBCEAAgGAEIABAMAIQACAYAQgAEIwABAAIRgACAAQjAAEAghGAAADBCEAAgGAEIABAMAIQACAYAQgAEIwABAAIRgACAAQjAAEAghGAAADBNEgATp8+PZWVlaUxY8bUrtu6dWsaPXp06tChQzrwwAPT2Wefnaqqqhpi9wAAGrWiB+Bzzz2XfvWrX6Vjjz22zvqxY8emBx98MN13333piSeeSO+9914666yzir17AACNXlED8OOP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" alt="Code similarity histogram">
      </div>
    </div>
    <p style="text-align: center">
      <i>Note: a score of -1 in the similarity matrix indicates the comparison was skipped</i>
    </p>

    <div class="row" style="font-size: small;">
      <div class="col3">
        <p>
          <b>Number of files tested (vertical):</b> 14<br>
          <b>Number above display threshold:</b> 9 (64.29%)<br><br>
          <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-test-files" aria-expanded="false" aria-controls="collapse-test-files">
            View <i>test</i> files
          </button>
        </p>
        <div class="collapse" id="collapse-test-files">
          <ul class="file-info-list">
              <li>0=dodanieNowychMetod.py</li> 
            
              <li>1=hfdh.py</li> 
            
              <li>2=fourthmethod.py</li> 
            
              <li>3=third-Method_with_vectors.py</li> 
            
              <li>4=first_method.py</li> 
            
              <li>5=second_method_changing_workflow.py</li> 
            
              <li>6=jargonmethod.py</li> 
            
              <li>7=5thWithDimensions.py</li> 
            
              <li>8=lcs.py</li> 
            
              <li>9=jaccard.py</li> 
            
              <li>10=modyfingConditions.py</li> 
            
              <li>11=utils.py</li> 
            
              <li>12=moss.py</li> 
            
              <li>13=manipulatingloops.py</li> 
            </ul>
        </div>
      </div>
      <div class="col3">
        <p>
          <b>Number of reference files (horizontal):</b> 14<br><br><br>
          <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-reference-files" aria-expanded="false" aria-controls="collapse-reference-files">
            View <i>reference</i> files
          </button>
        </p>
        <div class="collapse" id="collapse-reference-files">
          <ul class="file-info-list">
              <li>0=dodanieNowychMetod.py</li> 
            
              <li>1=hfdh.py</li> 
            
              <li>2=fourthmethod.py</li> 
            
              <li>3=third-Method_with_vectors.py</li> 
            
              <li>4=first_method.py</li> 
            
              <li>5=second_method_changing_workflow.py</li> 
            
              <li>6=jargonmethod.py</li> 
            
              <li>7=5thWithDimensions.py</li> 
            
              <li>8=lcs.py</li> 
            
              <li>9=jaccard.py</li> 
            
              <li>10=modyfingConditions.py</li> 
            
              <li>11=utils.py</li> 
            
              <li>12=moss.py</li> 
            
              <li>13=manipulatingloops.py</li> 
            </ul>
        </div>
      </div>
      <div class="col3">
        <p>
          <b>Execution params (see <code>copydetect --help</code>):</b><br><br><br>
          <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-exec-params" aria-expanded="false" aria-controls="collapse-exec-params">
            View execution parameters
          </button>
        </p>
        <div class="collapse" id="collapse-exec-params">
          <b>version:</b> 0.5.0<br>
          <b>Configuration:</b>
          <pre class="file-info-list">{
    "extensions": [
        "py"
    ],
    "same_name_only": false,
    "ignore_leaf": false,
    "disable_filtering": false,
    "truncate": false,
    "out_file": "./report.html",
    "css_files": [],
    "silent": false,
    "encoding": "utf-8",
    "window_size": 1,
    "noise_threshold": 25,
    "guarantee_threshold": 25,
    "display_threshold": 0.33,
    "test_directories": [
        "."
    ],
    "reference_directories": [
        "."
    ],
    "boilerplate_directories": [],
    "disable_autoopen": false
}</pre>
        </div>
      </div>
    </div>


  <h2>Matched Code</h2>
  <table class="table table-striped table-sm">
  <tbody class="table-light">
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>dodanieNowychMetod.py</i> (<b>100.00%</b>)<br>
    Reference file: <i>jargonmethod.py</i> (<b>93.32%</b>)<br>
    Token overlap: 322<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-1" aria-expanded="false" aria-controls="collapse-1">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-1">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code><span class='highlight-red'>import jaccard
import lcs
import moss

orig = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
    for j in range(n2):
        R[j] = arr[m + 1 + j]

    print(f&#34;left array {&#39; &#39;.join(map(str, L))} right array {&#39; &#39;.join(map(str, R))}&#34;)

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    while i &lt; n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j &lt; n2:
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;


fake = &#34;&#34;&#34;
def _allocate_and_fill_buffers(source, left_idx, mid_idx, right_idx):
    size_a = mid_idx - left_idx + 1
    size_b = right_idx - mid_idx

    left_buffer = [0] * size_a
    right_buffer = [0] * size_b

    for x in range(size_a):
        left_buffer[x] = source[left_idx + x]
        
    for y in range(size_b):
        right_buffer[y] = source[mid_idx + 1 + y]
        
    return left_buffer, right_buffer, size_a, size_b

def _execute_merge_logic(target_arr, left_buf, right_buf, count_a, count_b, start_k):
    ptr_a = 0
    ptr_b = 0
    ptr_main = start_k

    while ptr_a &lt; count_a and ptr_b &lt; count_b:
        if left_buf[ptr_a] &lt;= right_buf[ptr_b]:
            target_arr[ptr_main] = left_buf[ptr_a]
            ptr_a += 1
        else:
            target_arr[ptr_main] = right_buf[ptr_b]
            ptr_b += 1
        ptr_main += 1
        
    return ptr_a, ptr_b, ptr_main

def _finalize_remaining_items(target_arr, left_buf, right_buf, ptr_a, ptr_b, ptr_main, count_a, count_b):
    while ptr_a &lt; count_a:
        target_arr[ptr_main] = left_buf[ptr_a]
        ptr_a += 1
        ptr_main += 1
        
    while ptr_b &lt; count_b:
        target_arr[ptr_main] = right_buf[ptr_b]
        ptr_b += 1
        ptr_main += 1

def merge(arr, l, m, r):
  
    L_temp, R_temp, size_1, size_2 = _allocate_and_fill_buffers(arr, l, m, r)
        
    print(f&#34;left array {&#39; &#39;.join(map(str, L_temp))} right array {&#39; &#39;.join(map(str, R_temp))}&#34;)

    idx_l, idx_r, idx_k = _execute_merge_logic(arr, L_temp, R_temp, size_1, size_2, l)

    _finalize_remaining_items(arr, L_temp, R_temp, idx_l, idx_r, idx_k, size_1, size_2)

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

mos = moss.MossDetector.compute_similarity(orig, fake, &#34;python&#34;, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_matchcases&#34; )
print(mos)
spr = lcs.compute_lcs(orig, fake)
spr2 = jaccard.compute_jaccard_similarity(orig, fake, 3)
print(spr)
print(spr2)</span>
</code></pre>
        </div>
        <div class="col code-display">
          <pre><code><span class='highlight-green'>import jaccard
import lcs
import moss

orig = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
    for j in range(n2):
        R[j] = arr[m + 1 + j]

    print(f&#34;left array {&#39; &#39;.join(map(str, L))} right array {&#39; &#39;.join(map(str, R))}&#34;)

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    while i &lt; n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j &lt; n2:
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

fake=&#34;&#34;&#34;
class SortTelemetry:
    def __init__(self):
        self.comparisons = 0
        self.swaps = 0
        self.memory_accesses = 0
        self.integrity_checksum = 0

    def log_access(self, idx):
        self.memory_accesses += 1
        self.integrity_checksum = (self.integrity_checksum + idx) % 0xFF

_stats = SortTelemetry()

def _verify_partition_integrity(arr, start, end):
    if start &lt; 0 or end &gt; len(arr):
        return False
    
    local_hash = 0
    for x in range(start, min(end, len(arr))):
        local_hash += x
    return local_hash &gt;= 0

def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m
    
    _verify_partition_integrity(arr, l, r)
    
    partition_status = &#34;ACTIVE&#34;
    safety_buffer_zone = 0

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
        _stats.log_access(l + i)
        
    for j in range(n2):
        R[j] = arr[m + 1 + j]
        _stats.log_access(m + 1 + j)
        

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        _stats.comparisons += 1
        
        temp_val_check = L[i] + R[j]
        
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            safety_buffer_zone = L[i]
            i += 1
        else:
            arr[k] = R[j]
            safety_buffer_zone = R[j]
            j += 1
        
        _stats.swaps += 1
        k += 1

    while i &lt; n1:
        if partition_status == &#34;ACTIVE</span>&#34;:
            arr[k] = L[i]
            _stats.log_access(k)
            i += 1
            k += 1
            
    while j &lt; n2:
<span class='highlight-green'>        if partition_status == &#34;ACTIVE&#34;:
            arr[k] = R[j]
            _stats.log_access(k)
            j += 1
            k += 1

def mergeSort(arr, l, r):
    is_safe_execution = True
    
    if l &lt; r and is_safe_execution:
        m = l + (r - l) // 2
        
        _stats.memory_accesses += 1
        
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
    else:
        _stats.integrity_checksum -= 1

def run_sort_with_report(data):
    print(&#34;--- Initializing Sort Sequence ---</span>&#34;)
    mergeSort(data, 0, len(data) - 1)
    print(f&#34;Sort Complete. Metrics: Comp={_stats.comparisons}, Acc={_stats.memory_accesses}&#34;<span class='highlight-green'>)
&#34;&#34;&#34;

mos = moss.MossDetector.compute_similarity(orig, fake, &#34;python&#34;, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_matchcases&#34; )
print(mos)
spr = lcs.compute_lcs(orig, fake)
spr2 = jaccard.compute_jaccard_similarity(orig, fake, 3)
print(spr)
print(spr2)</span></code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>fourthmethod.py</i> (<b>100.00%</b>)<br>
    Reference file: <i>third-Method_with_vectors.py</i> (<b>98.50%</b>)<br>
    Token overlap: 207<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-2" aria-expanded="false" aria-controls="collapse-2">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-2">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code><span class='highlight-red'>import lcs
import moss

merge_git = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}

&#34;&#34;&#34;


merge_fake =&#34;&#34;&#34;
void merge(vector&lt;long long&gt;&amp; arr, long long left, long long mid, long right) {
    long long n1 = mid - left + 1;
    long long n2 = right - mid;
    
    vector&lt;long long&gt; L(n1), R(n2);

    for (long long i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (long long j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    long long i = 0; 
    long long j = 0; 
    long long k = left;

    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;long long&gt;&amp; arr, long long left, long right) {
    if (left &gt;= right) return;
    
    long long mid = left + (right - left) / 2;
    
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}
&#34;&#34;&#34;

mos = moss.MossDetector.compute_similarity(merge_git, merge_fake, &#34;cc&#34;)
print(mos)
ls = lcs.compute_lcs(merge_git, merge_fake)
print(ls)</span></code></pre>
        </div>
        <div class="col code-display">
          <pre><code><span class='highlight-green'>import lcs
import moss

merge_git = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}

&#34;&#34;&#34;

merge_fake = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left_arg, int mid_arg, int right_arg) {
    int left[1] = {left_arg};
    int mid[1] = {mid_arg};
    int right[1] = {right_arg};

    
    int n1[1]; 
    n1[0] = mid[0] - left[0] + 1;
    
    int n2[1];
    n2[0] = right[0] - mid[0];

    vector&lt;int&gt; L(n1[0]), R(n2[0]);

    for (int i = 0; i &lt; n1[0]; i++) L[i] = arr[left[0] + i];
    for (int j = 0; j &lt; n2[0]; j++) R[j] = arr[mid[0] + 1 + j];

    int i[1] = {0};
    int j[1] = {0};
    int k[1] = {left[0]};

    while (i[0] &lt; n1[0] &amp;&amp; j[0] &lt; n2[0]) {
       
        if (L[i[0]] &lt;= R[j[0]]) {
            arr[k[0]] = L[i[0]];
            i[0]++;
        } else {
            arr[k[0]] = R[j[0]];
            j[0]++;
        }
        k[0]++;
    }

    while (i[0] &lt; n1[0]) {
        arr[k[0]] = L[i[0]];
        i[0]++; k[0]++;
    }
    while (j[0] &lt; n2[0]) {
        arr[k[0]] = R[j[0]];
        j[0]++; k[0]++;
    }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left_arg, int right_arg) {
    int left[1] = {left_arg};
    int right[1] = {right_arg};

    if (left[0] &gt;= right[0]) return;

    int mid[1];
    mid[0] = left[0] + (right[0] - left[0]) / 2;

    mergeSort(arr, left[0], mid[0]);
    mergeSort(arr, mid[0] + 1, right[0]);
    merge(arr, left[0], mid[0], right[0]);
}
&#34;&#34;&#34;

mos = moss.MossDetector.compute_similarity(merge_git, merge_fake, &#34;cc&#34;</span>, &#34;merge&#34;<span class='highlight-green'>, &#34;merge_with_vecs&#34;)
print(mos)

ls = lcs.compute_lcs(merge_git, merge_fake)
print(ls)</span></code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>fourthmethod.py</i> (<b>100.00%</b>)<br>
    Reference file: <i>second_method_changing_workflow.py</i> (<b>98.49%</b>)<br>
    Token overlap: 207<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-3" aria-expanded="false" aria-controls="collapse-3">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-3">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code><span class='highlight-red'>import lcs
import moss

merge_git = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}

&#34;&#34;&#34;


merge_fake =&#34;&#34;&#34;
void merge(vector&lt;long long&gt;&amp; arr, long long left, long long mid, long right) {
    long long n1 = mid - left + 1;
    long long n2 = right - mid;
    
    vector&lt;long long&gt; L(n1), R(n2);

    for (long long i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (long long j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    long long i = 0; 
    long long j = 0; 
    long long k = left;

    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;long long&gt;&amp; arr, long long left, long right) {
    if (left &gt;= right) return;
    
    long long mid = left + (right - left) / 2;
    
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}
&#34;&#34;&#34;

mos = moss.MossDetector.compute_similarity(merge_git, merge_fake, &#34;cc&#34;)
print(mos)
ls = lcs.compute_lcs(merge_git, merge_fake)
print(ls)</span></code></pre>
        </div>
        <div class="col code-display">
          <pre><code><span class='highlight-green'>import lcs
import moss

merge_git = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}
&#34;&#34;&#34;


# merge_changing_workflow = &#34;&#34;&#34;
# void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
#
#     int n2 = right - mid;
#     int n1 = mid - left + 1;
#     vector&lt;int&gt; L(n1), R(n2);
#
#     for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];
#     for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
#
#     int j = 0, i = 0, k = left;
#     while (j &lt; n2 &amp;&amp; i &lt; n1) {
#         if (L[i] &gt; R[j]) {
#             arr[k] = R[j]; j++;
#         } else {
#             arr[k] = L[i]; i++;
#         }
#         k++;
#     }
#     while (j &lt; n2) { arr[k] = R[j];
#     j++;
#      k++; }
#     while (i &lt; n1) { arr[k] = L[i];
#     i++;
#     k++; }
# }
#
# void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
#     if (left &gt;= right) return;
#     int mid = left + (right - left) / 2;
#     mergeSort(arr, left, mid);
#     mergeSort(arr, mid + 1, right);
#     merge(arr, left, mid, right);
# }
# &#34;&#34;&#34;

lele= &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1, n2;
    int i, j, k;

    
    while (true) {
        n1 = mid - left + 1;
        n2 = right - mid;
        vector&lt;int&gt; L(n1), R(n2);

        
        for (j = 0; j &lt; n2; j++) {
            R[j] = arr[mid + 1 + j];
        }

        
        for (i = 0; i &lt; n1; i++) {
            L[i] = arr[left + i];
        }

        i = 0; j = 0; k = left;

       
        while (true) {
            if (i &gt;= n1 &amp;&amp; j &gt;= n2) break;

            if (j &gt;= n2) {          
                arr[k] = L[i]; i++;
            } 
            else if (i &gt;= n1) {     
                arr[k] = R[j]; j++;
            } 
            else if (R[j] &lt; L[i]) { 
                arr[k] = R[j]; j++; 
            } 
            else {
                arr[k] = L[i]; i++;
            }
            k++;
        }

        break; 
    }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    while (1) {
        if (left &gt;= right) break;
        
        int mid = left + (right - left) / 2;

       
        mergeSort(arr, mid + 1, right); 
        mergeSort(arr, left, mid);     

        merge(arr, left, mid, right);
        
        break;
    }
}
&#34;&#34;&#34;

mos = moss.MossDetector.compute_similarity(merge_git, lele, &#34;cc&#34;</span>, &#34;merge_sort&#34;<span class='highlight-green'>, &#34;merge_sort_with_changed_workflow&#34; )
print(mos)
spr = lcs.compute_lcs(merge_git, lele)
print(spr)

# Modyfikacja kodu polegajca na zmianie kolejnoci niezalenych blokw instrukcji oraz opakowaniu logiki w sztuczne ptle sterujce zredukowaa wskanik podobiestwa z poziomu plagiatu do zaledwie 15% (warto poniej progu szumu statystycznego).
#
# Jednoczenie wysoki wynik algorytmu LCS (75%) dowodzi, e semantyka i sownictwo kodu pozostay niemal nienaruszone. Oznacza to, e MOSS, polegajc na lokalnej spjnoci strukturalnej, generuje faszywe wyniki negatywne (False Negatives) w przypadku, gdy student zastosuje proste techniki inynierii kodu, ktre nie wymagaj zaawansowanej wiedzy programistycznej.</span></code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>fourthmethod.py</i> (<b>100.00%</b>)<br>
    Reference file: <i>5thWithDimensions.py</i> (<b>100.00%</b>)<br>
    Token overlap: 207<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-4" aria-expanded="false" aria-controls="collapse-4">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-4">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code><span class='highlight-red'>import lcs
import moss

merge_git = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}

&#34;&#34;&#34;


merge_fake =&#34;&#34;&#34;
void merge(vector&lt;long long&gt;&amp; arr, long long left, long long mid, long right) {
    long long n1 = mid - left + 1;
    long long n2 = right - mid;
    
    vector&lt;long long&gt; L(n1), R(n2);

    for (long long i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (long long j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    long long i = 0; 
    long long j = 0; 
    long long k = left;

    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;long long&gt;&amp; arr, long long left, long right) {
    if (left &gt;= right) return;
    
    long long mid = left + (right - left) / 2;
    
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}
&#34;&#34;&#34;

mos = moss.MossDetector.compute_similarity(merge_git, merge_fake, &#34;cc&#34;)
print(mos)
ls = lcs.compute_lcs(merge_git, merge_fake)
print(ls)</span></code></pre>
        </div>
        <div class="col code-display">
          <pre><code><span class='highlight-green'>import lcs
import moss

merge_git = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
    for j in range(n2):
        R[j] = arr[m + 1 + j]

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    while i &lt; n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j &lt; n2:
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

fake= &#34;&#34;&#34;

&#34;&#34;&#34;

mos = moss.MossDetector.compute_similarity(merge_git, fake, &#34;cc&#34;)
print(mos)
ls = lcs.compute_lcs(merge_git, fake)
print(ls)</span></code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>third-Method_with_vectors.py</i> (<b>100.00%</b>)<br>
    Reference file: <i>second_method_changing_workflow.py</i> (<b>100.00%</b>)<br>
    Token overlap: 267<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-5" aria-expanded="false" aria-controls="collapse-5">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-5">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code><span class='highlight-red'>import lcs
import moss

merge_git = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}

&#34;&#34;&#34;

merge_fake = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left_arg, int mid_arg, int right_arg) {
    int left[1] = {left_arg};
    int mid[1] = {mid_arg};
    int right[1] = {right_arg};

    
    int n1[1]; 
    n1[0] = mid[0] - left[0] + 1;
    
    int n2[1];
    n2[0] = right[0] - mid[0];

    vector&lt;int&gt; L(n1[0]), R(n2[0]);

    for (int i = 0; i &lt; n1[0]; i++) L[i] = arr[left[0] + i];
    for (int j = 0; j &lt; n2[0]; j++) R[j] = arr[mid[0] + 1 + j];

    int i[1] = {0};
    int j[1] = {0};
    int k[1] = {left[0]};

    while (i[0] &lt; n1[0] &amp;&amp; j[0] &lt; n2[0]) {
       
        if (L[i[0]] &lt;= R[j[0]]) {
            arr[k[0]] = L[i[0]];
            i[0]++;
        } else {
            arr[k[0]] = R[j[0]];
            j[0]++;
        }
        k[0]++;
    }

    while (i[0] &lt; n1[0]) {
        arr[k[0]] = L[i[0]];
        i[0]++; k[0]++;
    }
    while (j[0] &lt; n2[0]) {
        arr[k[0]] = R[j[0]];
        j[0]++; k[0]++;
    }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left_arg, int right_arg) {
    int left[1] = {left_arg};
    int right[1] = {right_arg};

    if (left[0] &gt;= right[0]) return;

    int mid[1];
    mid[0] = left[0] + (right[0] - left[0]) / 2;

    mergeSort(arr, left[0], mid[0]);
    mergeSort(arr, mid[0] + 1, right[0]);
    merge(arr, left[0], mid[0], right[0]);
}
&#34;&#34;&#34;

mos = moss.MossDetector.compute_similarity(merge_git, merge_fake, &#34;cc&#34;, &#34;merge&#34;, &#34;merge_with_vecs&#34;)
print(mos)

ls = lcs.compute_lcs(merge_git, merge_fake)
print(ls)</span></code></pre>
        </div>
        <div class="col code-display">
          <pre><code><span class='highlight-green'>import lcs
import moss

merge_git = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}
&#34;&#34;&#34;


# merge_changing_workflow = &#34;&#34;&#34;
# void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
#
#     int n2 = right - mid;
#     int n1 = mid - left + 1;
#     vector&lt;int&gt; L(n1), R(n2);
#
#     for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];
#     for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
#
#     int j = 0, i = 0, k = left;
#     while (j &lt; n2 &amp;&amp; i &lt; n1) {
#         if (L[i] &gt; R[j]) {
#             arr[k] = R[j]; j++;
#         } else {
#             arr[k] = L[i]; i++;
#         }
#         k++;
#     }
#     while (j &lt; n2) { arr[k] = R[j];
#     j++;
#      k++; }
#     while (i &lt; n1) { arr[k] = L[i];
#     i++;
#     k++; }
# }
#
# void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
#     if (left &gt;= right) return;
#     int mid = left + (right - left) / 2;
#     mergeSort(arr, left, mid);
#     mergeSort(arr, mid + 1, right);
#     merge(arr, left, mid, right);
# }
# &#34;&#34;&#34;

lele= &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1, n2;
    int i, j, k;

    
    while (true) {
        n1 = mid - left + 1;
        n2 = right - mid;
        vector&lt;int&gt; L(n1), R(n2);

        
        for (j = 0; j &lt; n2; j++) {
            R[j] = arr[mid + 1 + j];
        }

        
        for (i = 0; i &lt; n1; i++) {
            L[i] = arr[left + i];
        }

        i = 0; j = 0; k = left;

       
        while (true) {
            if (i &gt;= n1 &amp;&amp; j &gt;= n2) break;

            if (j &gt;= n2) {          
                arr[k] = L[i]; i++;
            } 
            else if (i &gt;= n1) {     
                arr[k] = R[j]; j++;
            } 
            else if (R[j] &lt; L[i]) { 
                arr[k] = R[j]; j++; 
            } 
            else {
                arr[k] = L[i]; i++;
            }
            k++;
        }

        break; 
    }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    while (1) {
        if (left &gt;= right) break;
        
        int mid = left + (right - left) / 2;

       
        mergeSort(arr, mid + 1, right); 
        mergeSort(arr, left, mid);     

        merge(arr, left, mid, right);
        
        break;
    }
}
&#34;&#34;&#34;

mos = moss.MossDetector.compute_similarity(merge_git, lele, &#34;cc&#34;, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_workflow&#34; )
print(mos)
spr = lcs.compute_lcs(merge_git, lele)
print(spr)

# Modyfikacja kodu polegajca na zmianie kolejnoci niezalenych blokw instrukcji oraz opakowaniu logiki w sztuczne ptle sterujce zredukowaa wskanik podobiestwa z poziomu plagiatu do zaledwie 15% (warto poniej progu szumu statystycznego).
#
# Jednoczenie wysoki wynik algorytmu LCS (75%) dowodzi, e semantyka i sownictwo kodu pozostay niemal nienaruszone. Oznacza to, e MOSS, polegajc na lokalnej spjnoci strukturalnej, generuje faszywe wyniki negatywne (False Negatives) w przypadku, gdy student zastosuje proste techniki inynierii kodu, ktre nie wymagaj zaawansowanej wiedzy programistycznej.</span></code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>third-Method_with_vectors.py</i> (<b>97.00%</b>)<br>
    Reference file: <i>jargonmethod.py</i> (<b>77.23%</b>)<br>
    Token overlap: 259<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-6" aria-expanded="false" aria-controls="collapse-6">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-6">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code><span class='highlight-red'>import lcs
import moss

merge_git = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}

&#34;&#34;&#34;

merge_fake = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left_arg, int mid_arg, int right_arg) {
    int left[1] = {left_arg};
    int mid[1] = {mid_arg};
    int right[1] = {right_arg};

    
    int n1[1]; 
    n1[0] = mid[0] - left[0] + 1;
    
    int n2[1];
    n2[0] = right[0] - mid[0];

    vector&lt;int&gt; L(n1[0]), R(n2[0]);

    for (int i = 0; i &lt; n1[0]; i++) L[i] = arr[left[0] + i];
    for (int j = 0; j &lt; n2[0]; j++) R[j] = arr[mid[0] + 1 + j];

    int i[1] = {0};
    int j[1] = {0};
    int k[1] = {left[0]};

    while (i[0] &lt; n1[0] &amp;&amp; j[0] &lt; n2[0]) {
       
        if (L[i[0]] &lt;= R[j[0]]) {
            arr[k[0]] = L[i[0]];
            i[0]++;
        } else {
            arr[k[0]] = R[j[0]];
            j[0]++;
        }
        k[0]++;
    }

    while (i[0] &lt; n1[0]) {
        arr[k[0]] = L[i[0]];
        i[0]++; k[0]++;
    }
    while (j[0] &lt; n2[0]) {
        arr[k[0]] = R[j[0]];
        j[0]++; k[0]++;
    }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left_arg, int right_arg) {
    int left[1] = {left_arg};
    int right[1] = {right_arg};

    if (left[0] &gt;= right[0]) return;

    int mid[1];
    mid[0] = left[0] + (right[0] - left[0]) / 2;

    mergeSort(arr, left[0], mid[0]);
    mergeSort(arr, mid[0] + 1, right[0]);
    merge(arr, left[0], mid[0], right[0]);
}
&#34;&#34;&#34;

mos = moss.MossDetector.compute_similarity(merge_git, merge_fake, &#34;cc&#34;, &#34;merge&#34;, &#34;merge_with_vecs&#34;)
print(mos)

ls = lcs.compute_lcs(merge_git, merge_fake)
</span>print(ls)</code></pre>
        </div>
        <div class="col code-display">
          <pre><code>import jaccard
<span class='highlight-green'>import lcs
import moss

orig = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
    for j in range(n2):
        R[j] = arr[m + 1 + j]

    print(f</span>&#34;left array {&#39; &#39;.join(map(str, L))} right array {&#39; &#39;.join(map(str, R))}&#34;<span class='highlight-green'>)

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    while i &lt; n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j &lt; n2:
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

fake=&#34;&#34;&#34;
class SortTelemetry:
    def __init__(self):
        self.comparisons = 0
        self.swaps = 0
        self.memory_accesses = 0
        self.integrity_checksum = 0

    def log_access(self, idx):
        self.memory_accesses += 1
        self.integrity_checksum = (self.integrity_checksum + idx) % 0xFF

_stats = SortTelemetry()

def _verify_partition_integrity(arr, start, end):
    if start &lt; 0 or end &gt; len(arr):
        return False
    
    local_hash = 0
    for x in range(start, min(end, len(arr))):
        local_hash += x
    return local_hash &gt;= 0

def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m
    
    _verify_partition_integrity(arr, l, r)
    
    partition_status = </span>&#34;ACTIVE&#34;<span class='highlight-green'>
    safety_buffer_zone = 0

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
        _stats.log_access(l + i)
        
    for j in range(n2):
        R[j] = arr[m + 1 + j]
        _stats.log_access(m + 1 + j)
        

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        _stats.comparisons += 1
        
        temp_val_check = L[i] + R[j]
        
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            safety_buffer_zone = L[i]
            i += 1
        else:
            arr[k] = R[j]
            safety_buffer_zone = R[j]
            j += 1
        
        _stats.swaps += 1
        k += 1

    while i &lt; n1:
        if partition_status == </span>&#34;ACTIVE&#34;:
            arr[k] = L[i]
            _stats.log_access(k)
            i += 1
            k += 1
            
    while j &lt; n2:
        if partition_status == &#34;ACTIVE&#34;<span class='highlight-green'>:
            arr[k] = R[j]
            _stats.log_access(k)
            j += 1
            k += 1

def mergeSort(arr, l, r):
    is_safe_execution = True
    
    if l &lt; r and is_safe_execution:
        m = l + (r - l) // 2
        
        _stats.memory_accesses += 1
        
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
    else:
        _stats.integrity_checksum -= 1

def run_sort_with_report(data):
    print(</span>&#34;--- Initializing Sort Sequence ---&#34;)
    mergeSort(data, 0, len(data) - 1)
    print(f&#34;Sort Complete. Metrics: Comp={_stats.comparisons}, Acc={_stats.memory_accesses}&#34;<span class='highlight-green'>)
&#34;&#34;&#34;

mos = moss.MossDetector.compute_similarity(orig, fake, &#34;python&#34;, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_matchcases&#34; )
print(mos)
spr = lcs.compute_lcs(orig, fake)
</span>spr2 = jaccard.compute_jaccard_similarity(orig, fake, 3)
print(spr)
print(spr2)</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>third-Method_with_vectors.py</i> (<b>97.00%</b>)<br>
    Reference file: <i>modyfingConditions.py</i> (<b>76.30%</b>)<br>
    Token overlap: 259<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-7" aria-expanded="false" aria-controls="collapse-7">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-7">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code><span class='highlight-red'>import lcs
import moss

merge_git = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}

&#34;&#34;&#34;

merge_fake = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left_arg, int mid_arg, int right_arg) {
    int left[1] = {left_arg};
    int mid[1] = {mid_arg};
    int right[1] = {right_arg};

    
    int n1[1]; 
    n1[0] = mid[0] - left[0] + 1;
    
    int n2[1];
    n2[0] = right[0] - mid[0];

    vector&lt;int&gt; L(n1[0]), R(n2[0]);

    for (int i = 0; i &lt; n1[0]; i++) L[i] = arr[left[0] + i];
    for (int j = 0; j &lt; n2[0]; j++) R[j] = arr[mid[0] + 1 + j];

    int i[1] = {0};
    int j[1] = {0};
    int k[1] = {left[0]};

    while (i[0] &lt; n1[0] &amp;&amp; j[0] &lt; n2[0]) {
       
        if (L[i[0]] &lt;= R[j[0]]) {
            arr[k[0]] = L[i[0]];
            i[0]++;
        } else {
            arr[k[0]] = R[j[0]];
            j[0]++;
        }
        k[0]++;
    }

    while (i[0] &lt; n1[0]) {
        arr[k[0]] = L[i[0]];
        i[0]++; k[0]++;
    }
    while (j[0] &lt; n2[0]) {
        arr[k[0]] = R[j[0]];
        j[0]++; k[0]++;
    }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left_arg, int right_arg) {
    int left[1] = {left_arg};
    int right[1] = {right_arg};

    if (left[0] &gt;= right[0]) return;

    int mid[1];
    mid[0] = left[0] + (right[0] - left[0]) / 2;

    mergeSort(arr, left[0], mid[0]);
    mergeSort(arr, mid[0] + 1, right[0]);
    merge(arr, left[0], mid[0], right[0]);
}
&#34;&#34;&#34;

mos = moss.MossDetector.compute_similarity(merge_git, merge_fake, &#34;cc&#34;, &#34;merge&#34;, &#34;merge_with_vecs&#34;)
print(mos)

ls = lcs.compute_lcs(merge_git, merge_fake)
</span>print(ls)</code></pre>
        </div>
        <div class="col code-display">
          <pre><code>import jaccard
<span class='highlight-green'>import lcs
import moss

orig = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
&#34;&#34;&#34;

fake_merge = &#34;&#34;&#34;

&#34;&#34;&#34;





mos = moss.MossDetector.compute_similarity(orig, fake_merge, &#34;python&#34;, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_matchcases&#34; )
print(mos)
spr = lcs.compute_lcs(orig, fake_merge)
</span>spr2 = jaccard.compute_jaccard_similarity(orig, fake_merge, 3)
print(spr)
print(spr2)

</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>second_method_changing_workflow.py</i> (<b>96.98%</b>)<br>
    Reference file: <i>jargonmethod.py</i> (<b>77.23%</b>)<br>
    Token overlap: 257<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-8" aria-expanded="false" aria-controls="collapse-8">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-8">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code><span class='highlight-red'>import lcs
import moss

merge_git = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}
&#34;&#34;&#34;


# merge_changing_workflow = &#34;&#34;&#34;
# void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
#
#     int n2 = right - mid;
#     int n1 = mid - left + 1;
#     vector&lt;int&gt; L(n1), R(n2);
#
#     for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];
#     for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
#
#     int j = 0, i = 0, k = left;
#     while (j &lt; n2 &amp;&amp; i &lt; n1) {
#         if (L[i] &gt; R[j]) {
#             arr[k] = R[j]; j++;
#         } else {
#             arr[k] = L[i]; i++;
#         }
#         k++;
#     }
#     while (j &lt; n2) { arr[k] = R[j];
#     j++;
#      k++; }
#     while (i &lt; n1) { arr[k] = L[i];
#     i++;
#     k++; }
# }
#
# void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
#     if (left &gt;= right) return;
#     int mid = left + (right - left) / 2;
#     mergeSort(arr, left, mid);
#     mergeSort(arr, mid + 1, right);
#     merge(arr, left, mid, right);
# }
# &#34;&#34;&#34;

lele= &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1, n2;
    int i, j, k;

    
    while (true) {
        n1 = mid - left + 1;
        n2 = right - mid;
        vector&lt;int&gt; L(n1), R(n2);

        
        for (j = 0; j &lt; n2; j++) {
            R[j] = arr[mid + 1 + j];
        }

        
        for (i = 0; i &lt; n1; i++) {
            L[i] = arr[left + i];
        }

        i = 0; j = 0; k = left;

       
        while (true) {
            if (i &gt;= n1 &amp;&amp; j &gt;= n2) break;

            if (j &gt;= n2) {          
                arr[k] = L[i]; i++;
            } 
            else if (i &gt;= n1) {     
                arr[k] = R[j]; j++;
            } 
            else if (R[j] &lt; L[i]) { 
                arr[k] = R[j]; j++; 
            } 
            else {
                arr[k] = L[i]; i++;
            }
            k++;
        }

        break; 
    }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    while (1) {
        if (left &gt;= right) break;
        
        int mid = left + (right - left) / 2;

       
        mergeSort(arr, mid + 1, right); 
        mergeSort(arr, left, mid);     

        merge(arr, left, mid, right);
        
        break;
    }
}
&#34;&#34;&#34;

mos = moss.MossDetector.compute_similarity(merge_git, lele, &#34;cc&#34;, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_workflow&#34; )
print(mos)
spr = lcs.compute_lcs(merge_git, lele)
</span>print(spr)

# Modyfikacja kodu polegajca na zmianie kolejnoci niezalenych blokw instrukcji oraz opakowaniu logiki w sztuczne ptle sterujce zredukowaa wskanik podobiestwa z poziomu plagiatu do zaledwie 15% (warto poniej progu szumu statystycznego).
#
# Jednoczenie wysoki wynik algorytmu LCS (75%) dowodzi, e semantyka i sownictwo kodu pozostay niemal nienaruszone. Oznacza to, e MOSS, polegajc na lokalnej spjnoci strukturalnej, generuje faszywe wyniki negatywne (False Negatives) w przypadku, gdy student zastosuje proste techniki inynierii kodu, ktre nie wymagaj zaawansowanej wiedzy programistycznej.</code></pre>
        </div>
        <div class="col code-display">
          <pre><code>import jaccard
<span class='highlight-green'>import lcs
import moss

orig = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
    for j in range(n2):
        R[j] = arr[m + 1 + j]

    print(f</span>&#34;left array {&#39; &#39;.join(map(str, L))} right array {&#39; &#39;.join(map(str, R))}&#34;<span class='highlight-green'>)

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    while i &lt; n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j &lt; n2:
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

fake=&#34;&#34;&#34;
class SortTelemetry:
    def __init__(self):
        self.comparisons = 0
        self.swaps = 0
        self.memory_accesses = 0
        self.integrity_checksum = 0

    def log_access(self, idx):
        self.memory_accesses += 1
        self.integrity_checksum = (self.integrity_checksum + idx) % 0xFF

_stats = SortTelemetry()

def _verify_partition_integrity(arr, start, end):
    if start &lt; 0 or end &gt; len(arr):
        return False
    
    local_hash = 0
    for x in range(start, min(end, len(arr))):
        local_hash += x
    return local_hash &gt;= 0

def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m
    
    _verify_partition_integrity(arr, l, r)
    
    partition_status = </span>&#34;ACTIVE&#34;<span class='highlight-green'>
    safety_buffer_zone = 0

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
        _stats.log_access(l + i)
        
    for j in range(n2):
        R[j] = arr[m + 1 + j]
        _stats.log_access(m + 1 + j)
        

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        _stats.comparisons += 1
        
        temp_val_check = L[i] + R[j]
        
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            safety_buffer_zone = L[i]
            i += 1
        else:
            arr[k] = R[j]
            safety_buffer_zone = R[j]
            j += 1
        
        _stats.swaps += 1
        k += 1

    while i &lt; n1:
        if partition_status == </span>&#34;ACTIVE&#34;:
            arr[k] = L[i]
            _stats.log_access(k)
            i += 1
            k += 1
            
    while j &lt; n2:
        if partition_status == &#34;ACTIVE&#34;<span class='highlight-green'>:
            arr[k] = R[j]
            _stats.log_access(k)
            j += 1
            k += 1

def mergeSort(arr, l, r):
    is_safe_execution = True
    
    if l &lt; r and is_safe_execution:
        m = l + (r - l) // 2
        
        _stats.memory_accesses += 1
        
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
    else:
        _stats.integrity_checksum -= 1

def run_sort_with_report(data):
    print(</span>&#34;--- Initializing Sort Sequence ---&#34;)
    mergeSort(data, 0, len(data) - 1)
    print(f&#34;Sort Complete. Metrics: Comp={_stats.comparisons}, Acc={_stats.memory_accesses}&#34;<span class='highlight-green'>)
&#34;&#34;&#34;

mos = moss.MossDetector.compute_similarity(orig, fake, &#34;python&#34;, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_matchcases&#34; )
print(mos)
spr = lcs.compute_lcs(orig, fake)
</span>spr2 = jaccard.compute_jaccard_similarity(orig, fake, 3)
print(spr)
print(spr2)</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>second_method_changing_workflow.py</i> (<b>96.98%</b>)<br>
    Reference file: <i>modyfingConditions.py</i> (<b>76.30%</b>)<br>
    Token overlap: 257<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-9" aria-expanded="false" aria-controls="collapse-9">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-9">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code><span class='highlight-red'>import lcs
import moss

merge_git = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}
&#34;&#34;&#34;


# merge_changing_workflow = &#34;&#34;&#34;
# void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
#
#     int n2 = right - mid;
#     int n1 = mid - left + 1;
#     vector&lt;int&gt; L(n1), R(n2);
#
#     for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];
#     for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
#
#     int j = 0, i = 0, k = left;
#     while (j &lt; n2 &amp;&amp; i &lt; n1) {
#         if (L[i] &gt; R[j]) {
#             arr[k] = R[j]; j++;
#         } else {
#             arr[k] = L[i]; i++;
#         }
#         k++;
#     }
#     while (j &lt; n2) { arr[k] = R[j];
#     j++;
#      k++; }
#     while (i &lt; n1) { arr[k] = L[i];
#     i++;
#     k++; }
# }
#
# void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
#     if (left &gt;= right) return;
#     int mid = left + (right - left) / 2;
#     mergeSort(arr, left, mid);
#     mergeSort(arr, mid + 1, right);
#     merge(arr, left, mid, right);
# }
# &#34;&#34;&#34;

lele= &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1, n2;
    int i, j, k;

    
    while (true) {
        n1 = mid - left + 1;
        n2 = right - mid;
        vector&lt;int&gt; L(n1), R(n2);

        
        for (j = 0; j &lt; n2; j++) {
            R[j] = arr[mid + 1 + j];
        }

        
        for (i = 0; i &lt; n1; i++) {
            L[i] = arr[left + i];
        }

        i = 0; j = 0; k = left;

       
        while (true) {
            if (i &gt;= n1 &amp;&amp; j &gt;= n2) break;

            if (j &gt;= n2) {          
                arr[k] = L[i]; i++;
            } 
            else if (i &gt;= n1) {     
                arr[k] = R[j]; j++;
            } 
            else if (R[j] &lt; L[i]) { 
                arr[k] = R[j]; j++; 
            } 
            else {
                arr[k] = L[i]; i++;
            }
            k++;
        }

        break; 
    }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    while (1) {
        if (left &gt;= right) break;
        
        int mid = left + (right - left) / 2;

       
        mergeSort(arr, mid + 1, right); 
        mergeSort(arr, left, mid);     

        merge(arr, left, mid, right);
        
        break;
    }
}
&#34;&#34;&#34;

mos = moss.MossDetector.compute_similarity(merge_git, lele, &#34;cc&#34;, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_workflow&#34; )
print(mos)
spr = lcs.compute_lcs(merge_git, lele)
</span>print(spr)

# Modyfikacja kodu polegajca na zmianie kolejnoci niezalenych blokw instrukcji oraz opakowaniu logiki w sztuczne ptle sterujce zredukowaa wskanik podobiestwa z poziomu plagiatu do zaledwie 15% (warto poniej progu szumu statystycznego).
#
# Jednoczenie wysoki wynik algorytmu LCS (75%) dowodzi, e semantyka i sownictwo kodu pozostay niemal nienaruszone. Oznacza to, e MOSS, polegajc na lokalnej spjnoci strukturalnej, generuje faszywe wyniki negatywne (False Negatives) w przypadku, gdy student zastosuje proste techniki inynierii kodu, ktre nie wymagaj zaawansowanej wiedzy programistycznej.</code></pre>
        </div>
        <div class="col code-display">
          <pre><code>import jaccard
<span class='highlight-green'>import lcs
import moss

orig = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
&#34;&#34;&#34;

fake_merge = &#34;&#34;&#34;

&#34;&#34;&#34;





mos = moss.MossDetector.compute_similarity(orig, fake_merge, &#34;python&#34;, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_matchcases&#34; )
print(mos)
spr = lcs.compute_lcs(orig, fake_merge)
</span>spr2 = jaccard.compute_jaccard_similarity(orig, fake_merge, 3)
print(spr)
print(spr2)

</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>first_method.py</i> (<b>95.53%</b>)<br>
    Reference file: <i>manipulatingloops.py</i> (<b>77.29%</b>)<br>
    Token overlap: 171<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-10" aria-expanded="false" aria-controls="collapse-10">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-10">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code><span class='highlight-red'>import lcs
import moss

merge_git = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}
&#34;&#34;&#34;

merge_zeros_ones = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int zero=0;
    int one=1;
    int n1 = one*(mid - left + one);
    int n2 = (right - mid) * one;
    vector&lt;int&gt; L(n1 + zero), R(n2+zero);

    for (int i = zero; i &lt; n1+zero; i++) L[i*one] = arr[left +zero + i];
    for (int j = zero * one; j &lt; n2*one; j++) R[j+zero] = arr[mid*one + 1*one + j*one];

    int i = zero, j = zero, k = left*one;
    while (i &lt; n1+zero &amp;&amp; j &lt; n2*one) {
        if (L[i*one] &lt;= R[j*one]) {
            arr[k+0] = L[i+0]; i++;
        } else {
            arr[k*one] = R[j*one]; j++;
        }
        k++;
    }
    while (i+zero &lt; n1*one) { arr[k*1] = L[i+0]; i++; k++; }
    while (j+zero &lt; n2*one) { arr[k*1] = R[j+0]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    int zero=0;
    int one=1;
    if (left+zero &gt;= right*one) return;
    int mid = left + (right - left+zero) / 2*one;
    mergeSort(arr, left*one, mid+zero);
    mergeSort(arr, mid + 1, right*one);
    merge(arr, left, mid+zero, right*one);
}
&#34;&#34;&#34;



# mos = moss.MossDetector.compute_similarity(merge_git, merge_zeros_ones, &#34;cc&#34;, &#34;merge&#34;, &#34;changed&#34;)
# print(mos)

spr = lcs.compute_lcs(merge_git, merge_zeros_ones)
</span>print(spr)

</code></pre>
        </div>
        <div class="col code-display">
          <pre><code>import jaccard
<span class='highlight-green'>import lcs
import moss

orig = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
    for j in range(n2):
        R[j] = arr[m + 1 + j]

    print(f</span>&#34;left array {&#39; &#39;.join(map(str, L))} right array {&#39; &#39;.join(map(str, R))}&#34;<span class='highlight-green'>)

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    while i &lt; n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j &lt; n2:
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

fake = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    
    i = 0
    while i &lt; n1:
        L[i] = arr[l + i]
        i += 1
        
   
    j = 0
    while j &lt; n2:
        R[j] = arr[m + 1 + j]
        j += 1
        
    print(f</span>&#34;left array {&#39; &#39;.join(map(str, L))} right array {&#39; &#39;.join(map(str, R))}&#34;<span class='highlight-green'>)

    i = j = 0
    k = l
    
    while True:
       
        if i &gt;= n1 or j &gt;= n2:
            break
            
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1
        
    while True:
        if i &gt;= n1:
            break
        arr[k] = L[i]
        i += 1
        k += 1
        
    
    while True:
        if j &gt;= n2:
            break
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

# mos = moss.MossDetector.compute_similarity(orig, fake, &#34;python&#34;, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_matchcases&#34; )
# print(mos)
spr = lcs.compute_lcs(orig, fake)
</span>spr2 = jaccard.compute_jaccard_similarity(orig, fake, 3)
print(spr)
print(spr2)
</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>third-Method_with_vectors.py</i> (<b>93.63%</b>)<br>
    Reference file: <i>5thWithDimensions.py</i> (<b>92.36%</b>)<br>
    Token overlap: 250<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-11" aria-expanded="false" aria-controls="collapse-11">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-11">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code><span class='highlight-red'>import lcs
import moss

merge_git = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}

&#34;&#34;&#34;

merge_fake = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left_arg, int mid_arg, int right_arg) {
    int left[1] = {left_arg};
    int mid[1] = {mid_arg};
    int right[1] = {right_arg};

    
    int n1[1]; 
    n1[0] = mid[0] - left[0] + 1;
    
    int n2[1];
    n2[0] = right[0] - mid[0];

    vector&lt;int&gt; L(n1[0]), R(n2[0]);

    for (int i = 0; i &lt; n1[0]; i++) L[i] = arr[left[0] + i];
    for (int j = 0; j &lt; n2[0]; j++) R[j] = arr[mid[0] + 1 + j];

    int i[1] = {0};
    int j[1] = {0};
    int k[1] = {left[0]};

    while (i[0] &lt; n1[0] &amp;&amp; j[0] &lt; n2[0]) {
       
        if (L[i[0]] &lt;= R[j[0]]) {
            arr[k[0]] = L[i[0]];
            i[0]++;
        } else {
            arr[k[0]] = R[j[0]];
            j[0]++;
        }
        k[0]++;
    }

    while (i[0] &lt; n1[0]) {
        arr[k[0]] = L[i[0]];
        i[0]++; k[0]++;
    }
    while (j[0] &lt; n2[0]) {
        arr[k[0]] = R[j[0]];
        j[0]++; k[0]++;
    }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left_arg, int right_arg) {
    int left[1] = {left_arg};
    int right[1] = {right_arg};

    if (left[0] &gt;= right[0]) return;

    int mid[1];
    mid[0] = left[0] + (right[0] - left[0]) / 2;

    mergeSort(arr, left[0], mid[0]);
    mergeSort(arr, mid[0] + 1, right[0]);
    merge(arr, left[0], mid[0], right[0]);
}
&#34;&#34;&#34;

mos = </span>moss.MossDetector.compute_similarity(merge_git, merge_fake, &#34;cc&#34;, &#34;merge&#34;<span class='highlight-red'>, &#34;merge_with_vecs&#34;)
print(mos)

ls = lcs.compute_lcs(merge_git, merge_fake)
print(ls)</span></code></pre>
        </div>
        <div class="col code-display">
          <pre><code><span class='highlight-green'>import lcs
import moss

merge_git = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
    for j in range(n2):
        R[j] = arr[m + 1 + j]

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    while i &lt; n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j &lt; n2:
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

fake= &#34;&#34;&#34;

&#34;&#34;&#34;

</span>mos = moss.MossDetector.compute_similarity(merge_git, fake<span class='highlight-green'>, &#34;cc&#34;)
print(mos)
ls = lcs.compute_lcs(merge_git, fake)
print(ls)</span></code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>second_method_changing_workflow.py</i> (<b>93.58%</b>)<br>
    Reference file: <i>5thWithDimensions.py</i> (<b>92.36%</b>)<br>
    Token overlap: 248<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-12" aria-expanded="false" aria-controls="collapse-12">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-12">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code><span class='highlight-red'>import lcs
import moss

merge_git = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}
&#34;&#34;&#34;


# merge_changing_workflow = &#34;&#34;&#34;
# void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
#
#     int n2 = right - mid;
#     int n1 = mid - left + 1;
#     vector&lt;int&gt; L(n1), R(n2);
#
#     for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];
#     for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
#
#     int j = 0, i = 0, k = left;
#     while (j &lt; n2 &amp;&amp; i &lt; n1) {
#         if (L[i] &gt; R[j]) {
#             arr[k] = R[j]; j++;
#         } else {
#             arr[k] = L[i]; i++;
#         }
#         k++;
#     }
#     while (j &lt; n2) { arr[k] = R[j];
#     j++;
#      k++; }
#     while (i &lt; n1) { arr[k] = L[i];
#     i++;
#     k++; }
# }
#
# void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
#     if (left &gt;= right) return;
#     int mid = left + (right - left) / 2;
#     mergeSort(arr, left, mid);
#     mergeSort(arr, mid + 1, right);
#     merge(arr, left, mid, right);
# }
# &#34;&#34;&#34;

lele= &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1, n2;
    int i, j, k;

    
    while (true) {
        n1 = mid - left + 1;
        n2 = right - mid;
        vector&lt;int&gt; L(n1), R(n2);

        
        for (j = 0; j &lt; n2; j++) {
            R[j] = arr[mid + 1 + j];
        }

        
        for (i = 0; i &lt; n1; i++) {
            L[i] = arr[left + i];
        }

        i = 0; j = 0; k = left;

       
        while (true) {
            if (i &gt;= n1 &amp;&amp; j &gt;= n2) break;

            if (j &gt;= n2) {          
                arr[k] = L[i]; i++;
            } 
            else if (i &gt;= n1) {     
                arr[k] = R[j]; j++;
            } 
            else if (R[j] &lt; L[i]) { 
                arr[k] = R[j]; j++; 
            } 
            else {
                arr[k] = L[i]; i++;
            }
            k++;
        }

        break; 
    }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    while (1) {
        if (left &gt;= right) break;
        
        int mid = left + (right - left) / 2;

       
        mergeSort(arr, mid + 1, right); 
        mergeSort(arr, left, mid);     

        merge(arr, left, mid, right);
        
        break;
    }
}
&#34;&#34;&#34;

mos = </span>moss.MossDetector.compute_similarity(merge_git, lele, &#34;cc&#34;, &#34;merge_sort&#34;<span class='highlight-red'>, &#34;merge_sort_with_changed_workflow&#34; )
print(mos)
spr = lcs.compute_lcs(merge_git, lele)
print(spr)

# Modyfikacja kodu polegajca na zmianie kolejnoci niezalenych blokw instrukcji oraz opakowaniu logiki w sztuczne ptle sterujce zredukowaa wskanik podobiestwa z poziomu plagiatu do zaledwie 15% (warto poniej progu szumu statystycznego).
#
# Jednoczenie wysoki wynik algorytmu LCS (75%) dowodzi, e semantyka i sownictwo kodu pozostay niemal nienaruszone. Oznacza to, e MOSS, polegajc na lokalnej spjnoci strukturalnej, generuje faszywe wyniki negatywne (False Negatives) w przypadku, gdy student zastosuje proste techniki inynierii kodu, ktre nie wymagaj zaawansowanej wiedzy programistycznej.</span></code></pre>
        </div>
        <div class="col code-display">
          <pre><code><span class='highlight-green'>import lcs
import moss

merge_git = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
    for j in range(n2):
        R[j] = arr[m + 1 + j]

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    while i &lt; n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j &lt; n2:
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

fake= &#34;&#34;&#34;

&#34;&#34;&#34;

</span>mos = moss.MossDetector.compute_similarity(merge_git, fake<span class='highlight-green'>, &#34;cc&#34;)
print(mos)
ls = lcs.compute_lcs(merge_git, fake)
print(ls)</span></code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>first_method.py</i> (<b>92.74%</b>)<br>
    Reference file: <i>second_method_changing_workflow.py</i> (<b>83.02%</b>)<br>
    Token overlap: 166<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-13" aria-expanded="false" aria-controls="collapse-13">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-13">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code><span class='highlight-red'>import lcs
import moss

merge_git = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}
&#34;&#34;&#34;

merge_zeros_ones = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int zero=0;
    int one=1;
    int n1 = one*(mid - left + one);
    int n2 = (right - mid) * one;
    vector&lt;int&gt; L(n1 + zero), R(n2+zero);

    for (int i = zero; i &lt; n1+zero; i++) L[i*one] = arr[left +zero + i];
    for (int j = zero * one; j &lt; n2*one; j++) R[j+zero] = arr[mid*one + 1*one + j*one];

    int i = zero, j = zero, k = left*one;
    while (i &lt; n1+zero &amp;&amp; j &lt; n2*one) {
        if (L[i*one] &lt;= R[j*one]) {
            arr[k+0] = L[i+0]; i++;
        } else {
            arr[k*one] = R[j*one]; j++;
        }
        k++;
    }
    while (i+zero &lt; n1*one) { arr[k*1] = L[i+0]; i++; k++; }
    while (j+zero &lt; n2*one) { arr[k*1] = R[j+0]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    int zero=0;
    int one=1;
    if (left+zero &gt;= right*one) return;
    int mid = left + (right - left+zero) / 2*one;
    mergeSort(arr, left*one, mid+zero);
    mergeSort(arr, mid + 1, right*one);
    merge(arr, left, mid+zero, right*one);
}
&#34;&#34;&#34;



# mos = moss.MossDetector.compute_similarity(merge_git, merge_zeros_ones, &#34;cc&#34;, &#34;merge&#34;, &#34;changed&#34;)
# print(mos)

spr = lcs.compute_lcs</span>(merge_git, merge_zeros_ones)
print(spr)

</code></pre>
        </div>
        <div class="col code-display">
          <pre><code><span class='highlight-green'>import lcs
import moss

merge_git = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}
&#34;&#34;&#34;


# merge_changing_workflow = &#34;&#34;&#34;
# void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
#
#     int n2 = right - mid;
#     int n1 = mid - left + 1;
#     vector&lt;int&gt; L(n1), R(n2);
#
#     for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];
#     for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
#
#     int j = 0, i = 0, k = left;
#     while (j &lt; n2 &amp;&amp; i &lt; n1) {
#         if (L[i] &gt; R[j]) {
#             arr[k] = R[j]; j++;
#         } else {
#             arr[k] = L[i]; i++;
#         }
#         k++;
#     }
#     while (j &lt; n2) { arr[k] = R[j];
#     j++;
#      k++; }
#     while (i &lt; n1) { arr[k] = L[i];
#     i++;
#     k++; }
# }
#
# void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
#     if (left &gt;= right) return;
#     int mid = left + (right - left) / 2;
#     mergeSort(arr, left, mid);
#     mergeSort(arr, mid + 1, right);
#     merge(arr, left, mid, right);
# }
# &#34;&#34;&#34;

lele= &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1, n2;
    int i, j, k;

    
    while (true) {
        n1 = mid - left + 1;
        n2 = right - mid;
        vector&lt;int&gt; L(n1), R(n2);

        
        for (j = 0; j &lt; n2; j++) {
            R[j] = arr[mid + 1 + j];
        }

        
        for (i = 0; i &lt; n1; i++) {
            L[i] = arr[left + i];
        }

        i = 0; j = 0; k = left;

       
        while (true) {
            if (i &gt;= n1 &amp;&amp; j &gt;= n2) break;

            if (j &gt;= n2) {          
                arr[k] = L[i]; i++;
            } 
            else if (i &gt;= n1) {     
                arr[k] = R[j]; j++;
            } 
            else if (R[j] &lt; L[i]) { 
                arr[k] = R[j]; j++; 
            } 
            else {
                arr[k] = L[i]; i++;
            }
            k++;
        }

        break; 
    }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    while (1) {
        if (left &gt;= right) break;
        
        int mid = left + (right - left) / 2;

       
        mergeSort(arr, mid + 1, right); 
        mergeSort(arr, left, mid);     

        merge(arr, left, mid, right);
        
        break;
    }
}
&#34;&#34;&#34;

mos = moss.MossDetector</span>.compute_similarity(merge_git, lele, &#34;cc&#34;, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_workflow&#34; )
print(mos)
spr = lcs.compute_lcs(merge_git, lele)
print(spr)

# Modyfikacja kodu polegajca na zmianie kolejnoci niezalenych blokw instrukcji oraz opakowaniu logiki w sztuczne ptle sterujce zredukowaa wskanik podobiestwa z poziomu plagiatu do zaledwie 15% (warto poniej progu szumu statystycznego).
#
# Jednoczenie wysoki wynik algorytmu LCS (75%) dowodzi, e semantyka i sownictwo kodu pozostay niemal nienaruszone. Oznacza to, e MOSS, polegajc na lokalnej spjnoci strukturalnej, generuje faszywe wyniki negatywne (False Negatives) w przypadku, gdy student zastosuje proste techniki inynierii kodu, ktre nie wymagaj zaawansowanej wiedzy programistycznej.</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>dodanieNowychMetod.py</i> (<b>91.61%</b>)<br>
    Reference file: <i>manipulatingloops.py</i> (<b>100.00%</b>)<br>
    Token overlap: 295<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-14" aria-expanded="false" aria-controls="collapse-14">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-14">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code><span class='highlight-red'>import jaccard
import lcs
import moss

orig = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
    for j in range(n2):
        R[j] = arr[m + 1 + j]

    print(f&#34;left array {&#39; &#39;.join(map(str, L))} right array {&#39; &#39;.join(map(str, R))}&#34;)

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    while i &lt; n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j &lt; n2:
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;


fake = &#34;&#34;&#34;
def _allocate_and_fill_buffers(source, left_idx, mid_idx, right_idx):
    size_a = mid_idx - left_idx + 1
    size_b = right_idx - mid_idx

    left_buffer = [0] * size_a
    right_buffer = [0] * size_b

    for x in range(size_a):
        left_buffer[x] = source[left_idx + x]
        
    for y in range(size_b):
        right_buffer[y] = source[mid_idx + 1 + y]
        
    return left_buffer, right_buffer, size_a, size_b

def _execute_merge_logic(target_arr, left_buf, right_buf, count_a, count_b, start_k):
    ptr_a = 0
    ptr_b = 0
    ptr_main = start_k

    while ptr_a &lt; count_a and ptr_b &lt; count_b:
        if left_buf[ptr_a] &lt;= right_buf[ptr_b]:
            target_arr[ptr_main] = left_buf[ptr_a]
            ptr_a += 1
        else:
            target_arr[ptr_main] = right_buf[ptr_b]
            ptr_b += 1
        ptr_main += 1
        
    return ptr_a, ptr_b, ptr_main

def _finalize_remaining_items(target_arr, left_buf, right_buf, ptr_a, ptr_b, ptr_main, count_a, count_b):
    while ptr_a &lt; count_a:
        target_arr[ptr_main] = left_buf[ptr_a]
        ptr_a += 1
        ptr_main += 1
        
    while ptr_b &lt; count_b:
        target_arr[ptr_main] = right_buf[ptr_b]
        ptr_b += 1
        ptr_main += 1

def merge(arr, l, m, r):
  
    L_temp, R_temp, size_1, size_2 = _allocate_and_fill_buffers(arr, l, m, r)
        
    print(f&#34;left array {&#39; &#39;.join(map(str, L_temp))} right array {&#39; &#39;.join(map(str, R_temp))}&#34;)

    idx_l, idx_r, idx_k = _execute_merge_logic(arr, L_temp, R_temp, size_1, size_2, l)

    _finalize_remaining_items(arr, L_temp, R_temp, idx_l, idx_r, idx_k, size_1, size_2)

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

mos = moss.MossDetector</span>.compute_similarity(orig, fake, &#34;python&#34;, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_matchcases&#34; )
print(mos)
<span class='highlight-red'>spr = lcs.compute_lcs(orig, fake)
spr2 = jaccard.compute_jaccard_similarity(orig, fake, 3)
print(spr)
print(spr2)</span>
</code></pre>
        </div>
        <div class="col code-display">
          <pre><code><span class='highlight-green'>import jaccard
import lcs
import moss

orig = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
    for j in range(n2):
        R[j] = arr[m + 1 + j]

    print(f&#34;left array {&#39; &#39;.join(map(str, L))} right array {&#39; &#39;.join(map(str, R))}&#34;)

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    while i &lt; n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j &lt; n2:
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

fake = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    
    i = 0
    while i &lt; n1:
        L[i] = arr[l + i]
        i += 1
        
   
    j = 0
    while j &lt; n2:
        R[j] = arr[m + 1 + j]
        j += 1
        
    print(f&#34;left array {&#39; &#39;.join(map(str, L))} right array {&#39; &#39;.join(map(str, R))}&#34;)

    i = j = 0
    k = l
    
    while True:
       
        if i &gt;= n1 or j &gt;= n2:
            break
            
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1
        
    while True:
        if i &gt;= n1:
            break
        arr[k] = L[i]
        i += 1
        k += 1
        
    
    while True:
        if j &gt;= n2:
            break
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

# mos = moss.MossDetector.compute_similarity(orig, fake, &#34;python&#34;, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_matchcases&#34; )
# print(mos)
spr = lcs.compute_lcs(orig, fake)
spr2 = jaccard.compute_jaccard_similarity(orig, fake, 3)
print(spr)
print(spr2)</span>
</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>first_method.py</i> (<b>91.06%</b>)<br>
    Reference file: <i>jargonmethod.py</i> (<b>66.09%</b>)<br>
    Token overlap: 163<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-15" aria-expanded="false" aria-controls="collapse-15">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-15">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code><span class='highlight-red'>import lcs
import moss

merge_git = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}
&#34;&#34;&#34;

merge_zeros_ones = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int zero=0;
    int one=1;
    int n1 = one*(mid - left + one);
    int n2 = (right - mid) * one;
    vector&lt;int&gt; L(n1 + zero), R(n2+zero);

    for (int i = zero; i &lt; n1+zero; i++) L[i*one] = arr[left +zero + i];
    for (int j = zero * one; j &lt; n2*one; j++) R[j+zero] = arr[mid*one + 1*one + j*one];

    int i = zero, j = zero, k = left*one;
    while (i &lt; n1+zero &amp;&amp; j &lt; n2*one) {
        if (L[i*one] &lt;= R[j*one]) {
            arr[k+0] = L[i+0]; i++;
        } else {
            arr[k*one] = R[j*one]; j++;
        }
        k++;
    }
    while (i+zero &lt; n1*one) { arr[k*1] = L[i+0]; i++; k++; }
    while (j+zero &lt; n2*one) { arr[k*1] = R[j+0]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    int zero=0;
    int one=1;
    if (left+zero &gt;= right*one) return;
    int mid = left + (right - left+zero) / 2*one;
    mergeSort(arr, left*one, mid+zero);
    mergeSort(arr, mid + 1, right*one);
    merge(arr, left, mid+zero, right*one);
}
&#34;&#34;&#34;



# mos = moss.MossDetector.compute_similarity(merge_git, merge_zeros_ones, &#34;cc&#34;, &#34;merge&#34;, &#34;changed&#34;)
# print(mos)

spr = </span>lcs.compute_lcs(merge_git, merge_zeros_ones)
print(spr)

</code></pre>
        </div>
        <div class="col code-display">
          <pre><code>import jaccard
<span class='highlight-green'>import lcs
import moss

orig = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
    for j in range(n2):
        R[j] = arr[m + 1 + j]

    print(f</span>&#34;left array {&#39; &#39;.join(map(str, L))} right array {&#39; &#39;.join(map(str, R))}&#34;<span class='highlight-green'>)

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    while i &lt; n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j &lt; n2:
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

fake=&#34;&#34;&#34;
class SortTelemetry:
    def __init__(self):
        self.comparisons = 0
        self.swaps = 0
        self.memory_accesses = 0
        self.integrity_checksum = 0

    def log_access(self, idx):
        self.memory_accesses += 1
        self.integrity_checksum = (self.integrity_checksum + idx) % 0xFF

_stats = SortTelemetry()

def _verify_partition_integrity(arr, start, end):
    if start &lt; 0 or end &gt; len(arr):
        return False
    
    local_hash = 0
    for x in range(start, min(end, len(arr))):
        local_hash += x
    return local_hash &gt;= 0

def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m
    
    _verify_partition_integrity(arr, l, r)
    
    partition_status = </span>&#34;ACTIVE&#34;<span class='highlight-green'>
    safety_buffer_zone = 0

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
        _stats.log_access(l + i)
        
    for j in range(n2):
        R[j] = arr[m + 1 + j]
        _stats.log_access(m + 1 + j)
        

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        _stats.comparisons += 1
        
        temp_val_check = L[i] + R[j]
        
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            safety_buffer_zone = L[i]
            i += 1
        else:
            arr[k] = R[j]
            safety_buffer_zone = R[j]
            j += 1
        
        _stats.swaps += 1
        k += 1

    while i &lt; n1:
        if partition_status == </span>&#34;ACTIVE&#34;:
            arr[k] = L[i]
            _stats.log_access(k)
            i += 1
            k += 1
            
    while j &lt; n2:
        if partition_status == &#34;ACTIVE&#34;<span class='highlight-green'>:
            arr[k] = R[j]
            _stats.log_access(k)
            j += 1
            k += 1

def mergeSort(arr, l, r):
    is_safe_execution = True
    
    if l &lt; r and is_safe_execution:
        m = l + (r - l) // 2
        
        _stats.memory_accesses += 1
        
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
    else:
        _stats.integrity_checksum -= 1

def run_sort_with_report(data):
    print(</span>&#34;--- Initializing Sort Sequence ---&#34;)
    mergeSort(data, 0, len(data) - 1)
    print(f&#34;Sort Complete. Metrics: Comp={_stats.comparisons}, Acc={_stats.memory_accesses}&#34;)
&#34;&#34;&#34;

mos = moss.MossDetector.compute_similarity(orig, fake, &#34;python&#34;, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_matchcases&#34; )
print(mos)
spr = lcs.compute_lcs(orig, fake)
spr2 = jaccard.compute_jaccard_similarity(orig, fake, 3)
print(spr)
print(spr2)</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>first_method.py</i> (<b>91.06%</b>)<br>
    Reference file: <i>5thWithDimensions.py</i> (<b>70.83%</b>)<br>
    Token overlap: 163<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-16" aria-expanded="false" aria-controls="collapse-16">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-16">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code><span class='highlight-red'>import lcs
import moss

merge_git = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}
&#34;&#34;&#34;

merge_zeros_ones = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int zero=0;
    int one=1;
    int n1 = one*(mid - left + one);
    int n2 = (right - mid) * one;
    vector&lt;int&gt; L(n1 + zero), R(n2+zero);

    for (int i = zero; i &lt; n1+zero; i++) L[i*one] = arr[left +zero + i];
    for (int j = zero * one; j &lt; n2*one; j++) R[j+zero] = arr[mid*one + 1*one + j*one];

    int i = zero, j = zero, k = left*one;
    while (i &lt; n1+zero &amp;&amp; j &lt; n2*one) {
        if (L[i*one] &lt;= R[j*one]) {
            arr[k+0] = L[i+0]; i++;
        } else {
            arr[k*one] = R[j*one]; j++;
        }
        k++;
    }
    while (i+zero &lt; n1*one) { arr[k*1] = L[i+0]; i++; k++; }
    while (j+zero &lt; n2*one) { arr[k*1] = R[j+0]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    int zero=0;
    int one=1;
    if (left+zero &gt;= right*one) return;
    int mid = left + (right - left+zero) / 2*one;
    mergeSort(arr, left*one, mid+zero);
    mergeSort(arr, mid + 1, right*one);
    merge(arr, left, mid+zero, right*one);
}
&#34;&#34;&#34;



# mos = moss.MossDetector.compute_similarity(merge_git, merge_zeros_ones, &#34;cc&#34;, &#34;merge&#34;, &#34;changed&#34;)
# print(mos)

spr = </span>lcs.compute_lcs(merge_git, merge_zeros_ones)
print(spr)

</code></pre>
        </div>
        <div class="col code-display">
          <pre><code><span class='highlight-green'>import lcs
import moss

merge_git = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
    for j in range(n2):
        R[j] = arr[m + 1 + j]

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    while i &lt; n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j &lt; n2:
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

fake= &#34;&#34;&#34;

&#34;&#34;&#34;

</span>mos = moss.MossDetector.compute_similarity(merge_git, fake, &#34;cc&#34;)
print(mos)
ls = lcs.compute_lcs(merge_git, fake)
print(ls)</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>first_method.py</i> (<b>91.06%</b>)<br>
    Reference file: <i>modyfingConditions.py</i> (<b>52.02%</b>)<br>
    Token overlap: 163<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-17" aria-expanded="false" aria-controls="collapse-17">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-17">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code><span class='highlight-red'>import lcs
import moss

merge_git = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}
&#34;&#34;&#34;

merge_zeros_ones = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int zero=0;
    int one=1;
    int n1 = one*(mid - left + one);
    int n2 = (right - mid) * one;
    vector&lt;int&gt; L(n1 + zero), R(n2+zero);

    for (int i = zero; i &lt; n1+zero; i++) L[i*one] = arr[left +zero + i];
    for (int j = zero * one; j &lt; n2*one; j++) R[j+zero] = arr[mid*one + 1*one + j*one];

    int i = zero, j = zero, k = left*one;
    while (i &lt; n1+zero &amp;&amp; j &lt; n2*one) {
        if (L[i*one] &lt;= R[j*one]) {
            arr[k+0] = L[i+0]; i++;
        } else {
            arr[k*one] = R[j*one]; j++;
        }
        k++;
    }
    while (i+zero &lt; n1*one) { arr[k*1] = L[i+0]; i++; k++; }
    while (j+zero &lt; n2*one) { arr[k*1] = R[j+0]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    int zero=0;
    int one=1;
    if (left+zero &gt;= right*one) return;
    int mid = left + (right - left+zero) / 2*one;
    mergeSort(arr, left*one, mid+zero);
    mergeSort(arr, mid + 1, right*one);
    merge(arr, left, mid+zero, right*one);
}
&#34;&#34;&#34;



# mos = moss.MossDetector.compute_similarity(merge_git, merge_zeros_ones, &#34;cc&#34;, &#34;merge&#34;, &#34;changed&#34;)
# print(mos)

spr = </span>lcs.compute_lcs(merge_git, merge_zeros_ones)
print(spr)

</code></pre>
        </div>
        <div class="col code-display">
          <pre><code>import jaccard
<span class='highlight-green'>import lcs
import moss

orig = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
&#34;&#34;&#34;

fake_merge = &#34;&#34;&#34;

&#34;&#34;&#34;





</span>mos = moss.MossDetector.compute_similarity(orig, fake_merge, &#34;python&#34;, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_matchcases&#34; )
print(mos)
spr = lcs.compute_lcs(orig, fake_merge)
spr2 = jaccard.compute_jaccard_similarity(orig, fake_merge, 3)
print(spr)
print(spr2)

</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>jargonmethod.py</i> (<b>87.38%</b>)<br>
    Reference file: <i>modyfingConditions.py</i> (<b>100.00%</b>)<br>
    Token overlap: 353<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-18" aria-expanded="false" aria-controls="collapse-18">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-18">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code><span class='highlight-red'>import jaccard
import lcs
import moss

orig = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
    for j in range(n2):
        R[j] = arr[m + 1 + j]

    print(f</span>&#34;left array {&#39; &#39;.join(map(str, L))} right array {&#39; &#39;.join(map(str, R))}&#34;<span class='highlight-red'>)

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    while i &lt; n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j &lt; n2:
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

fake=&#34;&#34;&#34;
class SortTelemetry:
    def __init__(self):
        self.comparisons = 0
        self.swaps = 0
        self.memory_accesses = 0
        self.integrity_checksum = 0

    def log_access(self, idx):
        self.memory_accesses += 1
        self.integrity_checksum = (self.integrity_checksum + idx) % 0xFF

_stats = SortTelemetry()

def _verify_partition_integrity(arr, start, end):
    if start &lt; 0 or end &gt; len(arr):
        return False
    
    local_hash = 0
    for x in range(start, min(end, len(arr))):
        local_hash += x
    return local_hash &gt;= 0

def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m
    
    _verify_partition_integrity(arr, l, r)
    
    partition_status = </span>&#34;ACTIVE&#34;<span class='highlight-red'>
    safety_buffer_zone = 0

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
        _stats.log_access(l + i)
        
    for j in range(n2):
        R[j] = arr[m + 1 + j]
        _stats.log_access(m + 1 + j)
        

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        _stats.comparisons += 1
        
        temp_val_check = L[i] + R[j]
        
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            safety_buffer_zone = L[i]
            i += 1
        else:
            arr[k] = R[j]
            safety_buffer_zone = R[j]
            j += 1
        
        _stats.swaps += 1
        k += 1

    while i &lt; n1:
        if partition_status == </span>&#34;ACTIVE&#34;:
            arr[k] = L[i]
            _stats.log_access(k)
            i += 1
            k += 1
            
    while j &lt; n2:
        if partition_status == &#34;ACTIVE&#34;<span class='highlight-red'>:
            arr[k] = R[j]
            _stats.log_access(k)
            j += 1
            k += 1

def mergeSort(arr, l, r):
    is_safe_execution = True
    
    if l &lt; r and is_safe_execution:
        m = l + (r - l) // 2
        
        _stats.memory_accesses += 1
        
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
    else:
        _stats.integrity_checksum -= 1

def run_sort_with_report(data):
    print(</span>&#34;--- Initializing Sort Sequence ---&#34;)
    mergeSort(data, 0, len(data) - 1)
    print(f&#34;Sort Complete. Metrics: Comp={_stats.comparisons}, Acc={_stats.memory_accesses}&#34;<span class='highlight-red'>)
&#34;&#34;&#34;

mos = moss.MossDetector.compute_similarity(orig, fake, &#34;python&#34;, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_matchcases&#34; )
print(mos)
spr = lcs.compute_lcs(orig, fake)
spr2 = jaccard.compute_jaccard_similarity(orig, fake, 3)
print(spr)
print(spr2)</span></code></pre>
        </div>
        <div class="col code-display">
          <pre><code><span class='highlight-green'>import jaccard
import lcs
import moss

orig = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
&#34;&#34;&#34;

fake_merge = &#34;&#34;&#34;

&#34;&#34;&#34;





mos = moss.MossDetector.compute_similarity(orig, fake_merge, &#34;python&#34;, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_matchcases&#34; )
print(mos)
spr = lcs.compute_lcs(orig, fake_merge)
spr2 = jaccard.compute_jaccard_similarity(orig, fake_merge, 3)
print(spr)
print(spr2)</span>

</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>dodanieNowychMetod.py</i> (<b>86.34%</b>)<br>
    Reference file: <i>modyfingConditions.py</i> (<b>100.00%</b>)<br>
    Token overlap: 278<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-19" aria-expanded="false" aria-controls="collapse-19">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-19">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code><span class='highlight-red'>import jaccard
import lcs
import moss

orig = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
    for j in range(n2):
        R[j] = arr[m + 1 + j]

    print(f</span>&#34;left array {&#39; &#39;.join(map(str, L))} right array {&#39; &#39;.join(map(str, R))}&#34;<span class='highlight-red'>)

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    while i &lt; n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j &lt; n2:
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;


fake = &#34;&#34;&#34;
def _allocate_and_fill_buffers(source, left_idx, mid_idx, right_idx):
    size_a = mid_idx - left_idx + 1
    size_b = right_idx - mid_idx

    left_buffer = [0] * size_a
    right_buffer = [0] * size_b

    for x in range(size_a):
        left_buffer[x] = source[left_idx + x]
        
    for y in range(size_b):
        right_buffer[y] = source[mid_idx + 1 + y]
        
    return left_buffer, right_buffer, size_a, size_b

def _execute_merge_logic(target_arr, left_buf, right_buf, count_a, count_b, start_k):
    ptr_a = 0
    ptr_b = 0
    ptr_main = start_k

    while ptr_a &lt; count_a and ptr_b &lt; count_b:
        if left_buf[ptr_a] &lt;= right_buf[ptr_b]:
            target_arr[ptr_main] = left_buf[ptr_a]
            ptr_a += 1
        else:
            target_arr[ptr_main] = right_buf[ptr_b]
            ptr_b += 1
        ptr_main += 1
        
    return ptr_a, ptr_b, ptr_main

def _finalize_remaining_items(target_arr, left_buf, right_buf, ptr_a, ptr_b, ptr_main, count_a, count_b):
    while ptr_a &lt; count_a:
        target_arr[ptr_main] = left_buf[ptr_a]
        ptr_a += 1
        ptr_main += 1
        
    while ptr_b &lt; count_b:
        target_arr[ptr_main] = right_buf[ptr_b]
        ptr_b += 1
        ptr_main += 1

def merge(arr, l, m, r):
  
    L_temp, R_temp, size_1, size_2 = _allocate_and_fill_buffers(arr, l, m, r)
        
    print(f</span>&#34;left array {&#39; &#39;.join(map(str, L_temp))} right array {&#39; &#39;.join(map(str, R_temp))}&#34;)

    idx_l, idx_r, idx_k = _execute_merge_logic(arr, L_temp, R_temp, size_1, size_2, l)

    _finalize_remaining_items(arr, L_temp, R_temp, idx_l, idx_r, idx_k, size_1, size_2)

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)<span class='highlight-red'>
        merge(arr, l, m, r)
&#34;&#34;&#34;

mos = moss.MossDetector.compute_similarity(orig, fake, &#34;python&#34;, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_matchcases&#34; )
print(mos)
spr = lcs.compute_lcs(orig, fake)
spr2 = jaccard.compute_jaccard_similarity(orig, fake, 3)
print(spr)
print(spr2)</span>
</code></pre>
        </div>
        <div class="col code-display">
          <pre><code><span class='highlight-green'>import jaccard
import lcs
import moss

orig = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
&#34;&#34;&#34;

fake_merge = &#34;&#34;&#34;

&#34;&#34;&#34;





mos = moss.MossDetector.compute_similarity(orig, fake_merge, &#34;python&#34;, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_matchcases&#34; )
print(mos)
spr = lcs.compute_lcs(orig, fake_merge)
spr2 = jaccard.compute_jaccard_similarity(orig, fake_merge, 3)
print(spr)
print(spr2)</span>

</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>jargonmethod.py</i> (<b>84.65%</b>)<br>
    Reference file: <i>manipulatingloops.py</i> (<b>100.00%</b>)<br>
    Token overlap: 342<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-20" aria-expanded="false" aria-controls="collapse-20">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-20">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code><span class='highlight-red'>import jaccard
import lcs
import moss

orig = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
    for j in range(n2):
        R[j] = arr[m + 1 + j]

    print(f&#34;left array {&#39; &#39;.join(map(str, L))} right array {&#39; &#39;.join(map(str, R))}&#34;)

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    while i &lt; n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j &lt; n2:
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

fake=&#34;&#34;&#34;
class SortTelemetry:
    def __init__(self):
        self.comparisons = 0
        self.swaps = 0
        self.memory_accesses = 0
        self.integrity_checksum = 0

    def log_access(self, idx):
        self.memory_accesses += 1
        self.integrity_checksum = (self.integrity_checksum + idx) % 0xFF

_stats = SortTelemetry()

def _verify_partition_integrity(arr, start, end):
    if start &lt; 0 or end &gt; len(arr):
        return False
    
    local_hash = 0
    for x in range(start, min(end, len(arr))):
        local_hash += x
    return local_hash &gt;= 0

def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m
    
    _verify_partition_integrity(arr, l, r)
    
    partition_status = &#34;ACTIVE&#34;
    safety_buffer_zone = 0

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
        _stats.log_access(l + i)
        
    for j in range(n2):
        R[j] = arr[m + 1 + j]
        _stats.log_access(m + 1 + j)
        

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        _stats.comparisons += 1
        
        temp_val_check = L[i] + R[j]
        
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            safety_buffer_zone = L[i]
            i += 1
        else:
            arr[k] = R[j]
            safety_buffer_zone = R[j]
            j += 1
        
        _stats.swaps += 1
        k += 1

    while i &lt; n1:
        if partition_status == &#34;ACTIVE</span>&#34;:
            arr[k] = L[i]
            _stats.log_access(k)
            i += 1
            k += 1
            
    while j &lt; n2:
<span class='highlight-red'>        if partition_status == &#34;ACTIVE&#34;:
            arr[k] = R[j]
            _stats.log_access(k)
            j += 1
            k += 1

def mergeSort(arr, l, r):
    is_safe_execution = True
    
    if l &lt; r and is_safe_execution:
        m = l + (r - l) // 2
        
        _stats.memory_accesses += 1
        
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
    else:
        _stats.integrity_checksum -= 1

def run_sort_with_report(data):
    print(&#34;--- Initializing Sort Sequence ---</span>&#34;)
    mergeSort(data, 0, len(data) - 1)
    print(f&#34;Sort Complete. Metrics: Comp={_stats.comparisons}, Acc={_stats.memory_accesses}&#34;)
&#34;&#34;&#34;

mos = moss.MossDetector.compute_similarity(orig, fake, &#34;python&#34;, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_matchcases&#34; )
print(mos)
<span class='highlight-red'>spr = lcs.compute_lcs(orig, fake)
spr2 = jaccard.compute_jaccard_similarity(orig, fake, 3)
print(spr)
print(spr2)</span></code></pre>
        </div>
        <div class="col code-display">
          <pre><code><span class='highlight-green'>import jaccard
import lcs
import moss

orig = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
    for j in range(n2):
        R[j] = arr[m + 1 + j]

    print(f&#34;left array {&#39; &#39;.join(map(str, L))} right array {&#39; &#39;.join(map(str, R))}&#34;)

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    while i &lt; n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j &lt; n2:
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

fake = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    
    i = 0
    while i &lt; n1:
        L[i] = arr[l + i]
        i += 1
        
   
    j = 0
    while j &lt; n2:
        R[j] = arr[m + 1 + j]
        j += 1
        
    print(f&#34;left array {&#39; &#39;.join(map(str, L))} right array {&#39; &#39;.join(map(str, R))}&#34;)

    i = j = 0
    k = l
    
    while True:
       
        if i &gt;= n1 or j &gt;= n2:
            break
            
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1
        
    while True:
        if i &gt;= n1:
            break
        arr[k] = L[i]
        i += 1
        k += 1
        
    
    while True:
        if j &gt;= n2:
            break
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

# mos = moss.MossDetector.compute_similarity(orig, fake, &#34;python&#34;, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_matchcases&#34; )
# print(mos)
spr = lcs.compute_lcs(orig, fake)
spr2 = jaccard.compute_jaccard_similarity(orig, fake, 3)
print(spr)
print(spr2)</span>
</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>third-Method_with_vectors.py</i> (<b>83.15%</b>)<br>
    Reference file: <i>first_method.py</i> (<b>92.74%</b>)<br>
    Token overlap: 222<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-21" aria-expanded="false" aria-controls="collapse-21">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-21">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code><span class='highlight-red'>import lcs
import moss

merge_git = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}

&#34;&#34;&#34;

merge_fake = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left_arg, int mid_arg, int right_arg) {
    int left[1] = {left_arg};
    int mid[1] = {mid_arg};
    int right[1] = {right_arg};

    
    int n1[1]; 
    n1[0] = mid[0] - left[0] + 1;
    
    int n2[1];
    n2[0] = right[0] - mid[0];

    vector&lt;int&gt; L(n1[0]), R(n2[0]);

    for (int i = 0; i &lt; n1[0]; i++) L[i] = arr[left[0] + i];
    for (int j = 0; j &lt; n2[0]; j++) R[j] = arr[mid[0] + 1 + j];

    int i[1] = {0};
    int j[1] = {0};
    int k[1] = {left[0]};

    while (i[0] &lt; n1[0] &amp;&amp; j[0] &lt; n2[0]) {
       
        if (L[i[0]] &lt;= R[j[0]]) {
            arr[k[0]] = L[i[0]];
            i[0]++;
        } else {
            arr[k[0]] = R[j[0]];
            j[0]++;
        }
        k[0]++;
    }

    while (i[0] &lt; n1[0]) {
        arr[k[0]] = L[i[0]];
        i[0]++; k[0]++;
    }
    while (j[0] &lt; n2[0]) {
        arr[k[0]] = R[j[0]];
        j[0]++; k[0]++;
    }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left_arg, int right_arg) {
    int left[1] = {left_arg};
    int right[1] = {right_arg};

    if (left[0] &gt;= right[0]) return;

    int mid[1];
    mid[0] = left[0] + (right[0] - left[0]) / 2;

    mergeSort(arr, left[0], mid[0]);
    mergeSort(arr, mid[0] + 1, right[0]);
    merge(arr, left[0], mid[0], right[0]);
}
&#34;&#34;&#34;

mos = moss.MossDetector</span>.compute_similarity(merge_git, merge_fake, &#34;cc&#34;, &#34;merge&#34;, &#34;merge_with_vecs&#34;)
print(mos)

ls = lcs.compute_lcs(merge_git, merge_fake)
print(ls)</code></pre>
        </div>
        <div class="col code-display">
          <pre><code><span class='highlight-green'>import lcs
import moss

merge_git = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}
&#34;&#34;&#34;

merge_zeros_ones = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int zero=0;
    int one=1;
    int n1 = one*(mid - left + one);
    int n2 = (right - mid) * one;
    vector&lt;int&gt; L(n1 + zero), R(n2+zero);

    for (int i = zero; i &lt; n1+zero; i++) L[i*one] = arr[left +zero + i];
    for (int j = zero * one; j &lt; n2*one; j++) R[j+zero] = arr[mid*one + 1*one + j*one];

    int i = zero, j = zero, k = left*one;
    while (i &lt; n1+zero &amp;&amp; j &lt; n2*one) {
        if (L[i*one] &lt;= R[j*one]) {
            arr[k+0] = L[i+0]; i++;
        } else {
            arr[k*one] = R[j*one]; j++;
        }
        k++;
    }
    while (i+zero &lt; n1*one) { arr[k*1] = L[i+0]; i++; k++; }
    while (j+zero &lt; n2*one) { arr[k*1] = R[j+0]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    int zero=0;
    int one=1;
    if (left+zero &gt;= right*one) return;
    int mid = left + (right - left+zero) / 2*one;
    mergeSort(arr, left*one, mid+zero);
    mergeSort(arr, mid + 1, right*one);
    merge(arr, left, mid+zero, right*one);
}
&#34;&#34;&#34;



# mos = moss.MossDetector.compute_similarity(merge_git, merge_zeros_ones, &#34;cc&#34;, &#34;merge&#34;, &#34;changed&#34;)
# print(mos)

spr = lcs.compute_lcs</span>(merge_git, merge_zeros_ones)
print(spr)

</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>third-Method_with_vectors.py</i> (<b>83.15%</b>)<br>
    Reference file: <i>manipulatingloops.py</i> (<b>75.59%</b>)<br>
    Token overlap: 222<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-22" aria-expanded="false" aria-controls="collapse-22">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-22">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code><span class='highlight-red'>import lcs
import moss

merge_git = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}

&#34;&#34;&#34;

merge_fake = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left_arg, int mid_arg, int right_arg) {
    int left[1] = {left_arg};
    int mid[1] = {mid_arg};
    int right[1] = {right_arg};

    
    int n1[1]; 
    n1[0] = mid[0] - left[0] + 1;
    
    int n2[1];
    n2[0] = right[0] - mid[0];

    vector&lt;int&gt; L(n1[0]), R(n2[0]);

    for (int i = 0; i &lt; n1[0]; i++) L[i] = arr[left[0] + i];
    for (int j = 0; j &lt; n2[0]; j++) R[j] = arr[mid[0] + 1 + j];

    int i[1] = {0};
    int j[1] = {0};
    int k[1] = {left[0]};

    while (i[0] &lt; n1[0] &amp;&amp; j[0] &lt; n2[0]) {
       
        if (L[i[0]] &lt;= R[j[0]]) {
            arr[k[0]] = L[i[0]];
            i[0]++;
        } else {
            arr[k[0]] = R[j[0]];
            j[0]++;
        }
        k[0]++;
    }

    while (i[0] &lt; n1[0]) {
        arr[k[0]] = L[i[0]];
        i[0]++; k[0]++;
    }
    while (j[0] &lt; n2[0]) {
        arr[k[0]] = R[j[0]];
        j[0]++; k[0]++;
    }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left_arg, int right_arg) {
    int left[1] = {left_arg};
    int right[1] = {right_arg};

    if (left[0] &gt;= right[0]) return;

    int mid[1];
    mid[0] = left[0] + (right[0] - left[0]) / 2;

    mergeSort(arr, left[0], mid[0]);
    mergeSort(arr, mid[0] + 1, right[0]);
    merge(arr, left[0], mid[0], right[0]);
}
&#34;&#34;&#34;

mos = moss.MossDetector</span>.compute_similarity(merge_git, merge_fake, &#34;cc&#34;, &#34;merge&#34;, &#34;merge_with_vecs&#34;)
print(mos)

ls = lcs.compute_lcs(merge_git, merge_fake)
print(ls)</code></pre>
        </div>
        <div class="col code-display">
          <pre><code>import jaccard
<span class='highlight-green'>import lcs
import moss

orig = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
    for j in range(n2):
        R[j] = arr[m + 1 + j]

    print(f</span>&#34;left array {&#39; &#39;.join(map(str, L))} right array {&#39; &#39;.join(map(str, R))}&#34;<span class='highlight-green'>)

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    while i &lt; n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j &lt; n2:
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

fake = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    
    i = 0
    while i &lt; n1:
        L[i] = arr[l + i]
        i += 1
        
   
    j = 0
    while j &lt; n2:
        R[j] = arr[m + 1 + j]
        j += 1
        
    print(f</span>&#34;left array {&#39; &#39;.join(map(str, L))} right array {&#39; &#39;.join(map(str, R))}&#34;<span class='highlight-green'>)

    i = j = 0
    k = l
    
    while True:
       
        if i &gt;= n1 or j &gt;= n2:
            break
            
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1
        
    while True:
        if i &gt;= n1:
            break
        arr[k] = L[i]
        i += 1
        k += 1
        
    
    while True:
        if j &gt;= n2:
            break
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

# mos = moss.MossDetector.compute_similarity(orig, fake, &#34;python&#34;, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_matchcases&#34; )
# print(mos)
spr = lcs.compute_lcs</span>(orig, fake)
spr2 = jaccard.compute_jaccard_similarity(orig, fake, 3)
print(spr)
print(spr2)
</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>second_method_changing_workflow.py</i> (<b>83.02%</b>)<br>
    Reference file: <i>manipulatingloops.py</i> (<b>75.59%</b>)<br>
    Token overlap: 220<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-23" aria-expanded="false" aria-controls="collapse-23">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-23">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code><span class='highlight-red'>import lcs
import moss

merge_git = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}
&#34;&#34;&#34;


# merge_changing_workflow = &#34;&#34;&#34;
# void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
#
#     int n2 = right - mid;
#     int n1 = mid - left + 1;
#     vector&lt;int&gt; L(n1), R(n2);
#
#     for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];
#     for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
#
#     int j = 0, i = 0, k = left;
#     while (j &lt; n2 &amp;&amp; i &lt; n1) {
#         if (L[i] &gt; R[j]) {
#             arr[k] = R[j]; j++;
#         } else {
#             arr[k] = L[i]; i++;
#         }
#         k++;
#     }
#     while (j &lt; n2) { arr[k] = R[j];
#     j++;
#      k++; }
#     while (i &lt; n1) { arr[k] = L[i];
#     i++;
#     k++; }
# }
#
# void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
#     if (left &gt;= right) return;
#     int mid = left + (right - left) / 2;
#     mergeSort(arr, left, mid);
#     mergeSort(arr, mid + 1, right);
#     merge(arr, left, mid, right);
# }
# &#34;&#34;&#34;

lele= &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1, n2;
    int i, j, k;

    
    while (true) {
        n1 = mid - left + 1;
        n2 = right - mid;
        vector&lt;int&gt; L(n1), R(n2);

        
        for (j = 0; j &lt; n2; j++) {
            R[j] = arr[mid + 1 + j];
        }

        
        for (i = 0; i &lt; n1; i++) {
            L[i] = arr[left + i];
        }

        i = 0; j = 0; k = left;

       
        while (true) {
            if (i &gt;= n1 &amp;&amp; j &gt;= n2) break;

            if (j &gt;= n2) {          
                arr[k] = L[i]; i++;
            } 
            else if (i &gt;= n1) {     
                arr[k] = R[j]; j++;
            } 
            else if (R[j] &lt; L[i]) { 
                arr[k] = R[j]; j++; 
            } 
            else {
                arr[k] = L[i]; i++;
            }
            k++;
        }

        break; 
    }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    while (1) {
        if (left &gt;= right) break;
        
        int mid = left + (right - left) / 2;

       
        mergeSort(arr, mid + 1, right); 
        mergeSort(arr, left, mid);     

        merge(arr, left, mid, right);
        
        break;
    }
}
&#34;&#34;&#34;

mos = moss.MossDetector</span>.compute_similarity(merge_git, lele, &#34;cc&#34;, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_workflow&#34; )
print(mos)
spr = lcs.compute_lcs(merge_git, lele)
print(spr)

# Modyfikacja kodu polegajca na zmianie kolejnoci niezalenych blokw instrukcji oraz opakowaniu logiki w sztuczne ptle sterujce zredukowaa wskanik podobiestwa z poziomu plagiatu do zaledwie 15% (warto poniej progu szumu statystycznego).
#
# Jednoczenie wysoki wynik algorytmu LCS (75%) dowodzi, e semantyka i sownictwo kodu pozostay niemal nienaruszone. Oznacza to, e MOSS, polegajc na lokalnej spjnoci strukturalnej, generuje faszywe wyniki negatywne (False Negatives) w przypadku, gdy student zastosuje proste techniki inynierii kodu, ktre nie wymagaj zaawansowanej wiedzy programistycznej.</code></pre>
        </div>
        <div class="col code-display">
          <pre><code>import jaccard
<span class='highlight-green'>import lcs
import moss

orig = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
    for j in range(n2):
        R[j] = arr[m + 1 + j]

    print(f</span>&#34;left array {&#39; &#39;.join(map(str, L))} right array {&#39; &#39;.join(map(str, R))}&#34;<span class='highlight-green'>)

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    while i &lt; n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j &lt; n2:
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

fake = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    
    i = 0
    while i &lt; n1:
        L[i] = arr[l + i]
        i += 1
        
   
    j = 0
    while j &lt; n2:
        R[j] = arr[m + 1 + j]
        j += 1
        
    print(f</span>&#34;left array {&#39; &#39;.join(map(str, L))} right array {&#39; &#39;.join(map(str, R))}&#34;<span class='highlight-green'>)

    i = j = 0
    k = l
    
    while True:
       
        if i &gt;= n1 or j &gt;= n2:
            break
            
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1
        
    while True:
        if i &gt;= n1:
            break
        arr[k] = L[i]
        i += 1
        k += 1
        
    
    while True:
        if j &gt;= n2:
            break
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

# mos = moss.MossDetector.compute_similarity(orig, fake, &#34;python&#34;, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_matchcases&#34; )
# print(mos)
spr = lcs.compute_lcs</span>(orig, fake)
spr2 = jaccard.compute_jaccard_similarity(orig, fake, 3)
print(spr)
print(spr2)
</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>fourthmethod.py</i> (<b>82.13%</b>)<br>
    Reference file: <i>first_method.py</i> (<b>92.74%</b>)<br>
    Token overlap: 170<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-24" aria-expanded="false" aria-controls="collapse-24">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-24">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code><span class='highlight-red'>import lcs
import moss

merge_git = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}

&#34;&#34;&#34;


merge_fake =&#34;&#34;&#34;
void merge(vector&lt;long long&gt;&amp; arr, long long left, long long mid, long right) {
    long long n1 = mid - left + 1;
    long long n2 = right - mid;
    
    vector&lt;long long&gt; L(n1), R(n2);

    for (long long i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (long long j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    long long i = 0; 
    long long j = 0; 
    long long k = left;

    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;long long&gt;&amp; arr, long long left, long right) {
    if (left &gt;= right) return;
    
    long long mid = left + (right - left) / 2;
    
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}
&#34;&#34;&#34;

mos = moss.MossDetector</span>.compute_similarity(merge_git, merge_fake, &#34;cc&#34;)
print(mos)
ls = lcs.compute_lcs(merge_git, merge_fake)
print(ls)</code></pre>
        </div>
        <div class="col code-display">
          <pre><code><span class='highlight-green'>import lcs
import moss

merge_git = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}
&#34;&#34;&#34;

merge_zeros_ones = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int zero=0;
    int one=1;
    int n1 = one*(mid - left + one);
    int n2 = (right - mid) * one;
    vector&lt;int&gt; L(n1 + zero), R(n2+zero);

    for (int i = zero; i &lt; n1+zero; i++) L[i*one] = arr[left +zero + i];
    for (int j = zero * one; j &lt; n2*one; j++) R[j+zero] = arr[mid*one + 1*one + j*one];

    int i = zero, j = zero, k = left*one;
    while (i &lt; n1+zero &amp;&amp; j &lt; n2*one) {
        if (L[i*one] &lt;= R[j*one]) {
            arr[k+0] = L[i+0]; i++;
        } else {
            arr[k*one] = R[j*one]; j++;
        }
        k++;
    }
    while (i+zero &lt; n1*one) { arr[k*1] = L[i+0]; i++; k++; }
    while (j+zero &lt; n2*one) { arr[k*1] = R[j+0]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    int zero=0;
    int one=1;
    if (left+zero &gt;= right*one) return;
    int mid = left + (right - left+zero) / 2*one;
    mergeSort(arr, left*one, mid+zero);
    mergeSort(arr, mid + 1, right*one);
    merge(arr, left, mid+zero, right*one);
}
&#34;&#34;&#34;



# mos = moss.MossDetector.compute_similarity(merge_git, merge_zeros_ones, &#34;cc&#34;, &#34;merge&#34;, &#34;changed&#34;)
# print(mos)

spr = lcs.compute_lcs</span>(merge_git, merge_zeros_ones)
print(spr)

</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>fourthmethod.py</i> (<b>82.13%</b>)<br>
    Reference file: <i>manipulatingloops.py</i> (<b>75.59%</b>)<br>
    Token overlap: 170<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-25" aria-expanded="false" aria-controls="collapse-25">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-25">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code><span class='highlight-red'>import lcs
import moss

merge_git = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}

&#34;&#34;&#34;


merge_fake =&#34;&#34;&#34;
void merge(vector&lt;long long&gt;&amp; arr, long long left, long long mid, long right) {
    long long n1 = mid - left + 1;
    long long n2 = right - mid;
    
    vector&lt;long long&gt; L(n1), R(n2);

    for (long long i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (long long j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    long long i = 0; 
    long long j = 0; 
    long long k = left;

    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;long long&gt;&amp; arr, long long left, long right) {
    if (left &gt;= right) return;
    
    long long mid = left + (right - left) / 2;
    
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}
&#34;&#34;&#34;

mos = moss.MossDetector</span>.compute_similarity(merge_git, merge_fake, &#34;cc&#34;)
print(mos)
ls = lcs.compute_lcs(merge_git, merge_fake)
print(ls)</code></pre>
        </div>
        <div class="col code-display">
          <pre><code>import jaccard
<span class='highlight-green'>import lcs
import moss

orig = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
    for j in range(n2):
        R[j] = arr[m + 1 + j]

    print(f</span>&#34;left array {&#39; &#39;.join(map(str, L))} right array {&#39; &#39;.join(map(str, R))}&#34;<span class='highlight-green'>)

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    while i &lt; n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j &lt; n2:
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

fake = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    
    i = 0
    while i &lt; n1:
        L[i] = arr[l + i]
        i += 1
        
   
    j = 0
    while j &lt; n2:
        R[j] = arr[m + 1 + j]
        j += 1
        
    print(f</span>&#34;left array {&#39; &#39;.join(map(str, L))} right array {&#39; &#39;.join(map(str, R))}&#34;<span class='highlight-green'>)

    i = j = 0
    k = l
    
    while True:
       
        if i &gt;= n1 or j &gt;= n2:
            break
            
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1
        
    while True:
        if i &gt;= n1:
            break
        arr[k] = L[i]
        i += 1
        k += 1
        
    
    while True:
        if j &gt;= n2:
            break
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

# mos = moss.MossDetector.compute_similarity(orig, fake, &#34;python&#34;, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_matchcases&#34; )
# print(mos)
spr = lcs.compute_lcs</span>(orig, fake)
spr2 = jaccard.compute_jaccard_similarity(orig, fake, 3)
print(spr)
print(spr2)
</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>modyfingConditions.py</i> (<b>81.50%</b>)<br>
    Reference file: <i>manipulatingloops.py</i> (<b>91.19%</b>)<br>
    Token overlap: 141<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-26" aria-expanded="false" aria-controls="collapse-26">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-26">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code><span class='highlight-red'>import jaccard
import lcs
import moss

orig = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
&#34;&#34;&#34;

fake_merge = &#34;&#34;&#34;

&#34;&#34;&#34;





</span>mos = moss.MossDetector.compute_similarity(orig, fake_merge, &#34;python&#34;, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_matchcases&#34; )
print(mos)
<span class='highlight-red'>spr = lcs.compute_lcs(orig, fake_merge)
spr2 = jaccard.compute_jaccard_similarity(orig, fake_merge, 3)
print(spr)
print(spr2)</span>

</code></pre>
        </div>
        <div class="col code-display">
          <pre><code><span class='highlight-green'>import jaccard
import lcs
import moss

orig = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
    for j in range(n2):
        R[j] = arr[m + 1 + j]

    print(f</span>&#34;left array {&#39; &#39;.join(map(str, L))} right array {&#39; &#39;.join(map(str, R))}&#34;<span class='highlight-green'>)

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    while i &lt; n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j &lt; n2:
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

fake = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    
    i = 0
    while i &lt; n1:
        L[i] = arr[l + i]
        i += 1
        
   
    j = 0
    while j &lt; n2:
        R[j] = arr[m + 1 + j]
        j += 1
        
    print(f</span>&#34;left array {&#39; &#39;.join(map(str, L))} right array {&#39; &#39;.join(map(str, R))}&#34;<span class='highlight-green'>)

    i = j = 0
    k = l
    
    while True:
       
        if i &gt;= n1 or j &gt;= n2:
            break
            
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1
        
    while True:
        if i &gt;= n1:
            break
        arr[k] = L[i]
        i += 1
        k += 1
        
    
    while True:
        if j &gt;= n2:
            break
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

# mos = moss.MossDetector.compute_similarity(orig, fake, &#34;python&#34;, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_matchcases&#34; )
# print(mos)
spr = lcs.compute_lcs(orig, fake)
spr2 = jaccard.compute_jaccard_similarity(orig, fake, 3)
print(spr)
print(spr2)</span>
</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>5thWithDimensions.py</i> (<b>81.25%</b>)<br>
    Reference file: <i>modyfingConditions.py</i> (<b>60.69%</b>)<br>
    Token overlap: 117<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-27" aria-expanded="false" aria-controls="collapse-27">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-27">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code><span class='highlight-red'>import lcs
import moss

merge_git = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
    for j in range(n2):
        R[j] = arr[m + 1 + j]

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    while i &lt; n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j &lt; n2:
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

fake= &#34;&#34;&#34;

&#34;&#34;&#34;

mos = moss.MossDetector.compute_similarity(merge_git, fake, &#34;cc&#34;</span>)
print(mos)
ls = lcs.compute_lcs(merge_git, fake)
print(ls)</code></pre>
        </div>
        <div class="col code-display">
          <pre><code>import jaccard
<span class='highlight-green'>import lcs
import moss

orig = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
&#34;&#34;&#34;

fake_merge = &#34;&#34;&#34;

&#34;&#34;&#34;





mos = moss.MossDetector.compute_similarity(orig, fake_merge, &#34;python&#34;</span>, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_matchcases&#34; )
print(mos)
spr = lcs.compute_lcs(orig, fake_merge)
spr2 = jaccard.compute_jaccard_similarity(orig, fake_merge, 3)
print(spr)
print(spr2)

</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>fourthmethod.py</i> (<b>80.68%</b>)<br>
    Reference file: <i>jargonmethod.py</i> (<b>66.09%</b>)<br>
    Token overlap: 167<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-28" aria-expanded="false" aria-controls="collapse-28">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-28">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code><span class='highlight-red'>import lcs
import moss

merge_git = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}

&#34;&#34;&#34;


merge_fake =&#34;&#34;&#34;
void merge(vector&lt;long long&gt;&amp; arr, long long left, long long mid, long right) {
    long long n1 = mid - left + 1;
    long long n2 = right - mid;
    
    vector&lt;long long&gt; L(n1), R(n2);

    for (long long i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (long long j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    long long i = 0; 
    long long j = 0; 
    long long k = left;

    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;long long&gt;&amp; arr, long long left, long right) {
    if (left &gt;= right) return;
    
    long long mid = left + (right - left) / 2;
    
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}
&#34;&#34;&#34;

mos = </span>moss.MossDetector.compute_similarity(merge_git, merge_fake, &#34;cc&#34;)
print(mos)
ls = lcs.compute_lcs(merge_git, merge_fake)
print(ls)</code></pre>
        </div>
        <div class="col code-display">
          <pre><code>import jaccard
<span class='highlight-green'>import lcs
import moss

orig = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
    for j in range(n2):
        R[j] = arr[m + 1 + j]

    print(f</span>&#34;left array {&#39; &#39;.join(map(str, L))} right array {&#39; &#39;.join(map(str, R))}&#34;<span class='highlight-green'>)

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    while i &lt; n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j &lt; n2:
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

fake=&#34;&#34;&#34;
class SortTelemetry:
    def __init__(self):
        self.comparisons = 0
        self.swaps = 0
        self.memory_accesses = 0
        self.integrity_checksum = 0

    def log_access(self, idx):
        self.memory_accesses += 1
        self.integrity_checksum = (self.integrity_checksum + idx) % 0xFF

_stats = SortTelemetry()

def _verify_partition_integrity(arr, start, end):
    if start &lt; 0 or end &gt; len(arr):
        return False
    
    local_hash = 0
    for x in range(start, min(end, len(arr))):
        local_hash += x
    return local_hash &gt;= 0

def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m
    
    _verify_partition_integrity(arr, l, r)
    
    partition_status = </span>&#34;ACTIVE&#34;<span class='highlight-green'>
    safety_buffer_zone = 0

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
        _stats.log_access(l + i)
        
    for j in range(n2):
        R[j] = arr[m + 1 + j]
        _stats.log_access(m + 1 + j)
        

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        _stats.comparisons += 1
        
        temp_val_check = L[i] + R[j]
        
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            safety_buffer_zone = L[i]
            i += 1
        else:
            arr[k] = R[j]
            safety_buffer_zone = R[j]
            j += 1
        
        _stats.swaps += 1
        k += 1

    while i &lt; n1:
        if partition_status == </span>&#34;ACTIVE&#34;:
            arr[k] = L[i]
            _stats.log_access(k)
            i += 1
            k += 1
            
    while j &lt; n2:
        if partition_status == &#34;ACTIVE&#34;<span class='highlight-green'>:
            arr[k] = R[j]
            _stats.log_access(k)
            j += 1
            k += 1

def mergeSort(arr, l, r):
    is_safe_execution = True
    
    if l &lt; r and is_safe_execution:
        m = l + (r - l) // 2
        
        _stats.memory_accesses += 1
        
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
    else:
        _stats.integrity_checksum -= 1

def run_sort_with_report(data):
    print(</span>&#34;--- Initializing Sort Sequence ---&#34;)
    mergeSort(data, 0, len(data) - 1)
    print(f&#34;Sort Complete. Metrics: Comp={_stats.comparisons}, Acc={_stats.memory_accesses}&#34;)
&#34;&#34;&#34;

mos = moss.MossDetector.compute_similarity(orig, fake, &#34;python&#34;, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_matchcases&#34; )
print(mos)
spr = lcs.compute_lcs(orig, fake)
spr2 = jaccard.compute_jaccard_similarity(orig, fake, 3)
print(spr)
print(spr2)</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>fourthmethod.py</i> (<b>80.68%</b>)<br>
    Reference file: <i>modyfingConditions.py</i> (<b>52.02%</b>)<br>
    Token overlap: 167<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-29" aria-expanded="false" aria-controls="collapse-29">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-29">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code><span class='highlight-red'>import lcs
import moss

merge_git = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}

&#34;&#34;&#34;


merge_fake =&#34;&#34;&#34;
void merge(vector&lt;long long&gt;&amp; arr, long long left, long long mid, long right) {
    long long n1 = mid - left + 1;
    long long n2 = right - mid;
    
    vector&lt;long long&gt; L(n1), R(n2);

    for (long long i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (long long j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    long long i = 0; 
    long long j = 0; 
    long long k = left;

    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;long long&gt;&amp; arr, long long left, long right) {
    if (left &gt;= right) return;
    
    long long mid = left + (right - left) / 2;
    
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}
&#34;&#34;&#34;

mos = </span>moss.MossDetector.compute_similarity(merge_git, merge_fake, &#34;cc&#34;)
print(mos)
ls = lcs.compute_lcs(merge_git, merge_fake)
print(ls)</code></pre>
        </div>
        <div class="col code-display">
          <pre><code>import jaccard
<span class='highlight-green'>import lcs
import moss

orig = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
&#34;&#34;&#34;

fake_merge = &#34;&#34;&#34;

&#34;&#34;&#34;





</span>mos = moss.MossDetector.compute_similarity(orig, fake_merge, &#34;python&#34;, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_matchcases&#34; )
print(mos)
spr = lcs.compute_lcs(orig, fake_merge)
spr2 = jaccard.compute_jaccard_similarity(orig, fake_merge, 3)
print(spr)
print(spr2)

</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>dodanieNowychMetod.py</i> (<b>79.19%</b>)<br>
    Reference file: <i>third-Method_with_vectors.py</i> (<b>97.00%</b>)<br>
    Token overlap: 255<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-30" aria-expanded="false" aria-controls="collapse-30">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-30">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code>import jaccard
<span class='highlight-red'>import lcs
import moss

orig = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
    for j in range(n2):
        R[j] = arr[m + 1 + j]

    print(f</span>&#34;left array {&#39; &#39;.join(map(str, L))} right array {&#39; &#39;.join(map(str, R))}&#34;<span class='highlight-red'>)

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    while i &lt; n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j &lt; n2:
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;


fake = &#34;&#34;&#34;
def _allocate_and_fill_buffers(source, left_idx, mid_idx, right_idx):
    size_a = mid_idx - left_idx + 1
    size_b = right_idx - mid_idx

    left_buffer = [0] * size_a
    right_buffer = [0] * size_b

    for x in range(size_a):
        left_buffer[x] = source[left_idx + x]
        
    for y in range(size_b):
        right_buffer[y] = source[mid_idx + 1 + y]
        
    return left_buffer, right_buffer, size_a, size_b

def _execute_merge_logic(target_arr, left_buf, right_buf, count_a, count_b, start_k):
    ptr_a = 0
    ptr_b = 0
    ptr_main = start_k

    while ptr_a &lt; count_a and ptr_b &lt; count_b:
        if left_buf[ptr_a] &lt;= right_buf[ptr_b]:
            target_arr[ptr_main] = left_buf[ptr_a]
            ptr_a += 1
        else:
            target_arr[ptr_main] = right_buf[ptr_b]
            ptr_b += 1
        ptr_main += 1
        
    return ptr_a, ptr_b, ptr_main

def _finalize_remaining_items(target_arr, left_buf, right_buf, ptr_a, ptr_b, ptr_main, count_a, count_b):
    while ptr_a &lt; count_a:
        target_arr[ptr_main] = left_buf[ptr_a]
        ptr_a += 1
        ptr_main += 1
        
    while ptr_b &lt; count_b:
        target_arr[ptr_main] = right_buf[ptr_b]
        ptr_b += 1
        ptr_main += 1

def merge(arr, l, m, r):
  
    L_temp, R_temp, size_1, size_2 = _allocate_and_fill_buffers(arr, l, m, r)
        
    print(f</span>&#34;left array {&#39; &#39;.join(map(str, L_temp))} right array {&#39; &#39;.join(map(str, R_temp))}&#34;<span class='highlight-red'>)

    idx_l, idx_r, idx_k = _execute_merge_logic(arr, L_temp, R_temp, size_1, size_2, l)

    _finalize_remaining_items(arr, L_temp, R_temp, idx_l, idx_r, idx_k, size_1, size_2)

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

mos = moss.MossDetector.compute_similarity(orig, fake, &#34;python&#34;, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_matchcases&#34; )
print(mos)
spr = lcs.compute_lcs(orig, fake)
</span>spr2 = jaccard.compute_jaccard_similarity(orig, fake, 3)
print(spr)
print(spr2)
</code></pre>
        </div>
        <div class="col code-display">
          <pre><code><span class='highlight-green'>import lcs
import moss

merge_git = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}

&#34;&#34;&#34;

merge_fake = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left_arg, int mid_arg, int right_arg) {
    int left[1] = {left_arg};
    int mid[1] = {mid_arg};
    int right[1] = {right_arg};

    
    int n1[1]; 
    n1[0] = mid[0] - left[0] + 1;
    
    int n2[1];
    n2[0] = right[0] - mid[0];

    vector&lt;int&gt; L(n1[0]), R(n2[0]);

    for (int i = 0; i &lt; n1[0]; i++) L[i] = arr[left[0] + i];
    for (int j = 0; j &lt; n2[0]; j++) R[j] = arr[mid[0] + 1 + j];

    int i[1] = {0};
    int j[1] = {0};
    int k[1] = {left[0]};

    while (i[0] &lt; n1[0] &amp;&amp; j[0] &lt; n2[0]) {
       
        if (L[i[0]] &lt;= R[j[0]]) {
            arr[k[0]] = L[i[0]];
            i[0]++;
        } else {
            arr[k[0]] = R[j[0]];
            j[0]++;
        }
        k[0]++;
    }

    while (i[0] &lt; n1[0]) {
        arr[k[0]] = L[i[0]];
        i[0]++; k[0]++;
    }
    while (j[0] &lt; n2[0]) {
        arr[k[0]] = R[j[0]];
        j[0]++; k[0]++;
    }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left_arg, int right_arg) {
    int left[1] = {left_arg};
    int right[1] = {right_arg};

    if (left[0] &gt;= right[0]) return;

    int mid[1];
    mid[0] = left[0] + (right[0] - left[0]) / 2;

    mergeSort(arr, left[0], mid[0]);
    mergeSort(arr, mid[0] + 1, right[0]);
    merge(arr, left[0], mid[0], right[0]);
}
&#34;&#34;&#34;

mos = moss.MossDetector.compute_similarity(merge_git, merge_fake, &#34;cc&#34;, &#34;merge&#34;, &#34;merge_with_vecs&#34;)
print(mos)

ls = lcs.compute_lcs(merge_git, merge_fake)
</span>print(ls)</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>dodanieNowychMetod.py</i> (<b>79.19%</b>)<br>
    Reference file: <i>second_method_changing_workflow.py</i> (<b>96.98%</b>)<br>
    Token overlap: 255<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-31" aria-expanded="false" aria-controls="collapse-31">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-31">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code>import jaccard
<span class='highlight-red'>import lcs
import moss

orig = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
    for j in range(n2):
        R[j] = arr[m + 1 + j]

    print(f</span>&#34;left array {&#39; &#39;.join(map(str, L))} right array {&#39; &#39;.join(map(str, R))}&#34;<span class='highlight-red'>)

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    while i &lt; n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j &lt; n2:
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;


fake = &#34;&#34;&#34;
def _allocate_and_fill_buffers(source, left_idx, mid_idx, right_idx):
    size_a = mid_idx - left_idx + 1
    size_b = right_idx - mid_idx

    left_buffer = [0] * size_a
    right_buffer = [0] * size_b

    for x in range(size_a):
        left_buffer[x] = source[left_idx + x]
        
    for y in range(size_b):
        right_buffer[y] = source[mid_idx + 1 + y]
        
    return left_buffer, right_buffer, size_a, size_b

def _execute_merge_logic(target_arr, left_buf, right_buf, count_a, count_b, start_k):
    ptr_a = 0
    ptr_b = 0
    ptr_main = start_k

    while ptr_a &lt; count_a and ptr_b &lt; count_b:
        if left_buf[ptr_a] &lt;= right_buf[ptr_b]:
            target_arr[ptr_main] = left_buf[ptr_a]
            ptr_a += 1
        else:
            target_arr[ptr_main] = right_buf[ptr_b]
            ptr_b += 1
        ptr_main += 1
        
    return ptr_a, ptr_b, ptr_main

def _finalize_remaining_items(target_arr, left_buf, right_buf, ptr_a, ptr_b, ptr_main, count_a, count_b):
    while ptr_a &lt; count_a:
        target_arr[ptr_main] = left_buf[ptr_a]
        ptr_a += 1
        ptr_main += 1
        
    while ptr_b &lt; count_b:
        target_arr[ptr_main] = right_buf[ptr_b]
        ptr_b += 1
        ptr_main += 1

def merge(arr, l, m, r):
  
    L_temp, R_temp, size_1, size_2 = _allocate_and_fill_buffers(arr, l, m, r)
        
    print(f</span>&#34;left array {&#39; &#39;.join(map(str, L_temp))} right array {&#39; &#39;.join(map(str, R_temp))}&#34;<span class='highlight-red'>)

    idx_l, idx_r, idx_k = _execute_merge_logic(arr, L_temp, R_temp, size_1, size_2, l)

    _finalize_remaining_items(arr, L_temp, R_temp, idx_l, idx_r, idx_k, size_1, size_2)

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

mos = moss.MossDetector.compute_similarity(orig, fake, &#34;python&#34;, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_matchcases&#34; )
print(mos)
spr = lcs.compute_lcs(orig, fake)
</span>spr2 = jaccard.compute_jaccard_similarity(orig, fake, 3)
print(spr)
print(spr2)
</code></pre>
        </div>
        <div class="col code-display">
          <pre><code><span class='highlight-green'>import lcs
import moss

merge_git = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}
&#34;&#34;&#34;


# merge_changing_workflow = &#34;&#34;&#34;
# void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
#
#     int n2 = right - mid;
#     int n1 = mid - left + 1;
#     vector&lt;int&gt; L(n1), R(n2);
#
#     for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];
#     for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
#
#     int j = 0, i = 0, k = left;
#     while (j &lt; n2 &amp;&amp; i &lt; n1) {
#         if (L[i] &gt; R[j]) {
#             arr[k] = R[j]; j++;
#         } else {
#             arr[k] = L[i]; i++;
#         }
#         k++;
#     }
#     while (j &lt; n2) { arr[k] = R[j];
#     j++;
#      k++; }
#     while (i &lt; n1) { arr[k] = L[i];
#     i++;
#     k++; }
# }
#
# void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
#     if (left &gt;= right) return;
#     int mid = left + (right - left) / 2;
#     mergeSort(arr, left, mid);
#     mergeSort(arr, mid + 1, right);
#     merge(arr, left, mid, right);
# }
# &#34;&#34;&#34;

lele= &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1, n2;
    int i, j, k;

    
    while (true) {
        n1 = mid - left + 1;
        n2 = right - mid;
        vector&lt;int&gt; L(n1), R(n2);

        
        for (j = 0; j &lt; n2; j++) {
            R[j] = arr[mid + 1 + j];
        }

        
        for (i = 0; i &lt; n1; i++) {
            L[i] = arr[left + i];
        }

        i = 0; j = 0; k = left;

       
        while (true) {
            if (i &gt;= n1 &amp;&amp; j &gt;= n2) break;

            if (j &gt;= n2) {          
                arr[k] = L[i]; i++;
            } 
            else if (i &gt;= n1) {     
                arr[k] = R[j]; j++;
            } 
            else if (R[j] &lt; L[i]) { 
                arr[k] = R[j]; j++; 
            } 
            else {
                arr[k] = L[i]; i++;
            }
            k++;
        }

        break; 
    }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    while (1) {
        if (left &gt;= right) break;
        
        int mid = left + (right - left) / 2;

       
        mergeSort(arr, mid + 1, right); 
        mergeSort(arr, left, mid);     

        merge(arr, left, mid, right);
        
        break;
    }
}
&#34;&#34;&#34;

mos = moss.MossDetector.compute_similarity(merge_git, lele, &#34;cc&#34;, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_workflow&#34; )
print(mos)
spr = lcs.compute_lcs(merge_git, lele)
</span>print(spr)

# Modyfikacja kodu polegajca na zmianie kolejnoci niezalenych blokw instrukcji oraz opakowaniu logiki w sztuczne ptle sterujce zredukowaa wskanik podobiestwa z poziomu plagiatu do zaledwie 15% (warto poniej progu szumu statystycznego).
#
# Jednoczenie wysoki wynik algorytmu LCS (75%) dowodzi, e semantyka i sownictwo kodu pozostay niemal nienaruszone. Oznacza to, e MOSS, polegajc na lokalnej spjnoci strukturalnej, generuje faszywe wyniki negatywne (False Negatives) w przypadku, gdy student zastosuje proste techniki inynierii kodu, ktre nie wymagaj zaawansowanej wiedzy programistycznej.</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>5thWithDimensions.py</i> (<b>70.83%</b>)<br>
    Reference file: <i>manipulatingloops.py</i> (<b>74.58%</b>)<br>
    Token overlap: 102<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-32" aria-expanded="false" aria-controls="collapse-32">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-32">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code><span class='highlight-red'>import lcs
import moss

merge_git = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
    for j in range(n2):
        R[j] = arr[m + 1 + j]

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    while i &lt; n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j &lt; n2:
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

fake= &#34;&#34;&#34;

&#34;&#34;&#34;

</span>mos = moss.MossDetector.compute_similarity(merge_git, fake, &#34;cc&#34;)
print(mos)
ls = lcs.compute_lcs(merge_git, fake)
print(ls)</code></pre>
        </div>
        <div class="col code-display">
          <pre><code>import jaccard
<span class='highlight-green'>import lcs
import moss

orig = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
    for j in range(n2):
        R[j] = arr[m + 1 + j]

    print(f</span>&#34;left array {&#39; &#39;.join(map(str, L))} right array {&#39; &#39;.join(map(str, R))}&#34;<span class='highlight-green'>)

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    while i &lt; n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j &lt; n2:
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

fake = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    
    i = 0
    while i &lt; n1:
        L[i] = arr[l + i]
        i += 1
        
   
    j = 0
    while j &lt; n2:
        R[j] = arr[m + 1 + j]
        j += 1
        
    print(f</span>&#34;left array {&#39; &#39;.join(map(str, L))} right array {&#39; &#39;.join(map(str, R))}&#34;<span class='highlight-green'>)

    i = j = 0
    k = l
    
    while True:
       
        if i &gt;= n1 or j &gt;= n2:
            break
            
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1
        
    while True:
        if i &gt;= n1:
            break
        arr[k] = L[i]
        i += 1
        k += 1
        
    
    while True:
        if j &gt;= n2:
            break
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

# mos = moss.MossDetector.compute_similarity(orig, fake, &#34;python&#34;, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_matchcases&#34; )
# print(mos)
spr = </span>lcs.compute_lcs(orig, fake)
spr2 = jaccard.compute_jaccard_similarity(orig, fake, 3)
print(spr)
print(spr2)
</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>dodanieNowychMetod.py</i> (<b>70.81%</b>)<br>
    Reference file: <i>fourthmethod.py</i> (<b>86.96%</b>)<br>
    Token overlap: 228<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-33" aria-expanded="false" aria-controls="collapse-33">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-33">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code>import jaccard
<span class='highlight-red'>import lcs
import moss

orig = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
    for j in range(n2):
        R[j] = arr[m + 1 + j]

    print(f</span>&#34;left array {&#39; &#39;.join(map(str, L))} right array {&#39; &#39;.join(map(str, R))}&#34;<span class='highlight-red'>)

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    while i &lt; n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j &lt; n2:
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;


fake = &#34;&#34;&#34;
def _allocate_and_fill_buffers(source, left_idx, mid_idx, right_idx):
    size_a = mid_idx - left_idx + 1
    size_b = right_idx - mid_idx

    left_buffer = [0] * size_a
    right_buffer = [0] * size_b

    for x in range(size_a):
        left_buffer[x] = source[left_idx + x]
        
    for y in range(size_b):
        right_buffer[y] = source[mid_idx + 1 + y]
        
    return left_buffer, right_buffer, size_a, size_b

def _execute_merge_logic(target_arr, left_buf, right_buf, count_a, count_b, start_k):
    ptr_a = 0
    ptr_b = 0
    ptr_main = start_k

    while ptr_a &lt; count_a and ptr_b &lt; count_b:
        if left_buf[ptr_a] &lt;= right_buf[ptr_b]:
            target_arr[ptr_main] = left_buf[ptr_a]
            ptr_a += 1
        else:
            target_arr[ptr_main] = right_buf[ptr_b]
            ptr_b += 1
        ptr_main += 1
        
    return ptr_a, ptr_b, ptr_main

def _finalize_remaining_items(target_arr, left_buf, right_buf, ptr_a, ptr_b, ptr_main, count_a, count_b):
    while ptr_a &lt; count_a:
        target_arr[ptr_main] = left_buf[ptr_a]
        ptr_a += 1
        ptr_main += 1
        
    while ptr_b &lt; count_b:
        target_arr[ptr_main] = right_buf[ptr_b]
        ptr_b += 1
        ptr_main += 1

def merge(arr, l, m, r):
  
    L_temp, R_temp, size_1, size_2 = _allocate_and_fill_buffers(arr, l, m, r)
        
    print(f</span>&#34;left array {&#39; &#39;.join(map(str, L_temp))} right array {&#39; &#39;.join(map(str, R_temp))}&#34;<span class='highlight-red'>)

    idx_l, idx_r, idx_k = _execute_merge_logic(arr, L_temp, R_temp, size_1, size_2, l)

    _finalize_remaining_items(arr, L_temp, R_temp, idx_l, idx_r, idx_k, size_1, size_2)

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

mos = moss.MossDetector.compute_similarity(orig, fake, &#34;python&#34;</span>, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_matchcases&#34; )
print(mos)
spr = lcs.compute_lcs(orig, fake)
spr2 = jaccard.compute_jaccard_similarity(orig, fake, 3)
print(spr)
print(spr2)
</code></pre>
        </div>
        <div class="col code-display">
          <pre><code><span class='highlight-green'>import lcs
import moss

merge_git = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}

&#34;&#34;&#34;


merge_fake =&#34;&#34;&#34;
void merge(vector&lt;long long&gt;&amp; arr, long long left, long long mid, long right) {
    long long n1 = mid - left + 1;
    long long n2 = right - mid;
    
    vector&lt;long long&gt; L(n1), R(n2);

    for (long long i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (long long j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    long long i = 0; 
    long long j = 0; 
    long long k = left;

    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;long long&gt;&amp; arr, long long left, long right) {
    if (left &gt;= right) return;
    
    long long mid = left + (right - left) / 2;
    
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}
&#34;&#34;&#34;

mos = moss.MossDetector.compute_similarity(merge_git, merge_fake, &#34;cc&#34;</span>)
print(mos)
ls = lcs.compute_lcs(merge_git, merge_fake)
print(ls)</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>dodanieNowychMetod.py</i> (<b>67.70%</b>)<br>
    Reference file: <i>first_method.py</i> (<b>92.74%</b>)<br>
    Token overlap: 218<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-34" aria-expanded="false" aria-controls="collapse-34">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-34">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code>import jaccard
<span class='highlight-red'>import lcs
import moss

orig = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
    for j in range(n2):
        R[j] = arr[m + 1 + j]

    print(f</span>&#34;left array {&#39; &#39;.join(map(str, L))} right array {&#39; &#39;.join(map(str, R))}&#34;<span class='highlight-red'>)

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    while i &lt; n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j &lt; n2:
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;


fake = &#34;&#34;&#34;
def _allocate_and_fill_buffers(source, left_idx, mid_idx, right_idx):
    size_a = mid_idx - left_idx + 1
    size_b = right_idx - mid_idx

    left_buffer = [0] * size_a
    right_buffer = [0] * size_b

    for x in range(size_a):
        left_buffer[x] = source[left_idx + x]
        
    for y in range(size_b):
        right_buffer[y] = source[mid_idx + 1 + y]
        
    return left_buffer, right_buffer, size_a, size_b

def _execute_merge_logic(target_arr, left_buf, right_buf, count_a, count_b, start_k):
    ptr_a = 0
    ptr_b = 0
    ptr_main = start_k

    while ptr_a &lt; count_a and ptr_b &lt; count_b:
        if left_buf[ptr_a] &lt;= right_buf[ptr_b]:
            target_arr[ptr_main] = left_buf[ptr_a]
            ptr_a += 1
        else:
            target_arr[ptr_main] = right_buf[ptr_b]
            ptr_b += 1
        ptr_main += 1
        
    return ptr_a, ptr_b, ptr_main

def _finalize_remaining_items(target_arr, left_buf, right_buf, ptr_a, ptr_b, ptr_main, count_a, count_b):
    while ptr_a &lt; count_a:
        target_arr[ptr_main] = left_buf[ptr_a]
        ptr_a += 1
        ptr_main += 1
        
    while ptr_b &lt; count_b:
        target_arr[ptr_main] = right_buf[ptr_b]
        ptr_b += 1
        ptr_main += 1

def merge(arr, l, m, r):
  
    L_temp, R_temp, size_1, size_2 = _allocate_and_fill_buffers(arr, l, m, r)
        
    print(f</span>&#34;left array {&#39; &#39;.join(map(str, L_temp))} right array {&#39; &#39;.join(map(str, R_temp))}&#34;<span class='highlight-red'>)

    idx_l, idx_r, idx_k = _execute_merge_logic(arr, L_temp, R_temp, size_1, size_2, l)

    _finalize_remaining_items(arr, L_temp, R_temp, idx_l, idx_r, idx_k, size_1, size_2)

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

mos = moss.MossDetector</span>.compute_similarity(orig, fake, &#34;python&#34;, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_matchcases&#34; )
print(mos)
spr = lcs.compute_lcs(orig, fake)
spr2 = jaccard.compute_jaccard_similarity(orig, fake, 3)
print(spr)
print(spr2)
</code></pre>
        </div>
        <div class="col code-display">
          <pre><code><span class='highlight-green'>import lcs
import moss

merge_git = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector&lt;int&gt; L(n1), R(n2);

    for (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i &lt; n1) { arr[k] = L[i]; i++; k++; }
    while (j &lt; n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    if (left &gt;= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}
&#34;&#34;&#34;

merge_zeros_ones = &#34;&#34;&#34;
void merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    int zero=0;
    int one=1;
    int n1 = one*(mid - left + one);
    int n2 = (right - mid) * one;
    vector&lt;int&gt; L(n1 + zero), R(n2+zero);

    for (int i = zero; i &lt; n1+zero; i++) L[i*one] = arr[left +zero + i];
    for (int j = zero * one; j &lt; n2*one; j++) R[j+zero] = arr[mid*one + 1*one + j*one];

    int i = zero, j = zero, k = left*one;
    while (i &lt; n1+zero &amp;&amp; j &lt; n2*one) {
        if (L[i*one] &lt;= R[j*one]) {
            arr[k+0] = L[i+0]; i++;
        } else {
            arr[k*one] = R[j*one]; j++;
        }
        k++;
    }
    while (i+zero &lt; n1*one) { arr[k*1] = L[i+0]; i++; k++; }
    while (j+zero &lt; n2*one) { arr[k*1] = R[j+0]; j++; k++; }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    int zero=0;
    int one=1;
    if (left+zero &gt;= right*one) return;
    int mid = left + (right - left+zero) / 2*one;
    mergeSort(arr, left*one, mid+zero);
    mergeSort(arr, mid + 1, right*one);
    merge(arr, left, mid+zero, right*one);
}
&#34;&#34;&#34;



# mos = moss.MossDetector.compute_similarity(merge_git, merge_zeros_ones, &#34;cc&#34;, &#34;merge&#34;, &#34;changed&#34;)
# print(mos)

spr = lcs.compute_lcs</span>(merge_git, merge_zeros_ones)
print(spr)

</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>jargonmethod.py</i> (<b>66.09%</b>)<br>
    Reference file: <i>5thWithDimensions.py</i> (<b>70.83%</b>)<br>
    Token overlap: 267<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-35" aria-expanded="false" aria-controls="collapse-35">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-35">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code>import jaccard
<span class='highlight-red'>import lcs
import moss

orig = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
    for j in range(n2):
        R[j] = arr[m + 1 + j]

    print(f</span>&#34;left array {&#39; &#39;.join(map(str, L))} right array {&#39; &#39;.join(map(str, R))}&#34;<span class='highlight-red'>)

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    while i &lt; n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j &lt; n2:
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

fake=&#34;&#34;&#34;
class SortTelemetry:
    def __init__(self):
        self.comparisons = 0
        self.swaps = 0
        self.memory_accesses = 0
        self.integrity_checksum = 0

    def log_access(self, idx):
        self.memory_accesses += 1
        self.integrity_checksum = (self.integrity_checksum + idx) % 0xFF

_stats = SortTelemetry()

def _verify_partition_integrity(arr, start, end):
    if start &lt; 0 or end &gt; len(arr):
        return False
    
    local_hash = 0
    for x in range(start, min(end, len(arr))):
        local_hash += x
    return local_hash &gt;= 0

def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m
    
    _verify_partition_integrity(arr, l, r)
    
    partition_status = </span>&#34;ACTIVE&#34;<span class='highlight-red'>
    safety_buffer_zone = 0

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
        _stats.log_access(l + i)
        
    for j in range(n2):
        R[j] = arr[m + 1 + j]
        _stats.log_access(m + 1 + j)
        

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        _stats.comparisons += 1
        
        temp_val_check = L[i] + R[j]
        
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            safety_buffer_zone = L[i]
            i += 1
        else:
            arr[k] = R[j]
            safety_buffer_zone = R[j]
            j += 1
        
        _stats.swaps += 1
        k += 1

    while i &lt; n1:
        if partition_status == </span>&#34;ACTIVE&#34;:
            arr[k] = L[i]
            _stats.log_access(k)
            i += 1
            k += 1
            
    while j &lt; n2:
        if partition_status == &#34;ACTIVE&#34;<span class='highlight-red'>:
            arr[k] = R[j]
            _stats.log_access(k)
            j += 1
            k += 1

def mergeSort(arr, l, r):
    is_safe_execution = True
    
    if l &lt; r and is_safe_execution:
        m = l + (r - l) // 2
        
        _stats.memory_accesses += 1
        
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
    else:
        _stats.integrity_checksum -= 1

def run_sort_with_report(data):
    print(</span>&#34;--- Initializing Sort Sequence ---&#34;)
    mergeSort(data, 0, len(data) - 1)
    print(f&#34;Sort Complete. Metrics: Comp={_stats.comparisons}, Acc={_stats.memory_accesses}&#34;)
&#34;&#34;&#34;

mos = moss.MossDetector.compute_similarity(orig, fake, &#34;python&#34;, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_matchcases&#34; )
print(mos)
spr = lcs.compute_lcs(orig, fake)
spr2 = jaccard.compute_jaccard_similarity(orig, fake, 3)
print(spr)
print(spr2)</code></pre>
        </div>
        <div class="col code-display">
          <pre><code><span class='highlight-green'>import lcs
import moss

merge_git = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
    for j in range(n2):
        R[j] = arr[m + 1 + j]

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    while i &lt; n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j &lt; n2:
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

fake= &#34;&#34;&#34;

&#34;&#34;&#34;

</span>mos = moss.MossDetector.compute_similarity(merge_git, fake, &#34;cc&#34;)
print(mos)
ls = lcs.compute_lcs(merge_git, fake)
print(ls)</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>dodanieNowychMetod.py</i> (<b>59.32%</b>)<br>
    Reference file: <i>5thWithDimensions.py</i> (<b>70.83%</b>)<br>
    Token overlap: 191<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-36" aria-expanded="false" aria-controls="collapse-36">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-36">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code>import jaccard
<span class='highlight-red'>import lcs
import moss

orig = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
    for j in range(n2):
        R[j] = arr[m + 1 + j]

    print(f</span>&#34;left array {&#39; &#39;.join(map(str, L))} right array {&#39; &#39;.join(map(str, R))}&#34;<span class='highlight-red'>)

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    while i &lt; n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j &lt; n2:
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;


fake = &#34;&#34;&#34;
def _allocate_and_fill_buffers(source, left_idx, mid_idx, right_idx):
    size_a = mid_idx - left_idx + 1
    size_b = right_idx - mid_idx

    left_buffer = [0] * size_a
    right_buffer = [0] * size_b

    for x in range(size_a):
        left_buffer[x] = source[left_idx + x]
        
    for y in range(size_b):
        right_buffer[y] = source[mid_idx + 1 + y]
        
    return left_buffer, right_buffer, size_a, size_b

def _execute_merge_logic(target_arr, left_buf, right_buf, count_a, count_b, start_k):
    ptr_a = 0
    ptr_b = 0
    ptr_main = start_k

    while ptr_a &lt; count_a and ptr_b &lt; count_b:
        if left_buf[ptr_a] &lt;= right_buf[ptr_b]:
            target_arr[ptr_main] = left_buf[ptr_a]
            ptr_a += 1
        else:
            target_arr[ptr_main] = right_buf[ptr_b]
            ptr_b += 1
        ptr_main += 1
        
    return ptr_a, ptr_b, ptr_main

def _finalize_remaining_items(target_arr, left_buf, right_buf, ptr_a, ptr_b, ptr_main, count_a, count_b):
    while ptr_a &lt; count_a:
        target_arr[ptr_main] = left_buf[ptr_a]
        ptr_a += 1
        ptr_main += 1
        
    while ptr_b &lt; count_b:
        target_arr[ptr_main] = right_buf[ptr_b]
        ptr_b += 1
        ptr_main += 1

def merge(arr, l, m, r):
  
    L_temp, R_temp, size_1, size_2 = _allocate_and_fill_buffers(arr, l, m, r)
        
    print(f</span>&#34;left array {&#39; &#39;.join(map(str, L_temp))} right array {&#39; &#39;.join(map(str, R_temp))}&#34;)

    idx_l, idx_r, idx_k = _execute_merge_logic(arr, L_temp, R_temp, size_1, size_2, l)

    _finalize_remaining_items(arr, L_temp, R_temp, idx_l, idx_r, idx_k, size_1, size_2)

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

mos = moss.MossDetector.compute_similarity(orig, fake, &#34;python&#34;, &#34;merge_sort&#34;, &#34;merge_sort_with_changed_matchcases&#34; )
print(mos)
spr = lcs.compute_lcs(orig, fake)
spr2 = jaccard.compute_jaccard_similarity(orig, fake, 3)
print(spr)
print(spr2)
</code></pre>
        </div>
        <div class="col code-display">
          <pre><code><span class='highlight-green'>import lcs
import moss

merge_git = &#34;&#34;&#34;
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    for i in range(n1):
        L[i] = arr[l + i]
    for j in range(n2):
        R[j] = arr[m + 1 + j]

    i = j = 0
    k = l

    while i &lt; n1 and j &lt; n2:
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    while i &lt; n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j &lt; n2:
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)
&#34;&#34;&#34;

fake= &#34;&#34;&#34;

&#34;&#34;&#34;

</span>mos = moss.MossDetector.compute_similarity(merge_git, fake, &#34;cc&#34;)
print(mos)
ls = lcs.compute_lcs(merge_git, fake)
print(ls)</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  </tbody>
  </table>
</div>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-kQtW33rZJAHjgefvhyyzcGF3C5TFyBQBA13V1RKPf4uH+bwyzQxZ6CmMZHmNBEfJ" crossorigin="anonymous"></script>
</body>